<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>By Selim - AtÄ±f Zinciri GÃ¶rselleÅŸtirici</title>

<script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
:root{
  --bg: linear-gradient(135deg,#f7f9ff,#e9eeff);
  --accent:#2b4eff; --shadow: rgba(43,78,255,0.15);
  --card:#fff; --text:#111;
}
body.dark{ --bg: linear-gradient(135deg,#0f1116,#1a1d23); --accent:#00bfff; --card:#1f1f1f; --text:#eee; --shadow: rgba(0,191,255,0.18); }
body{ margin:0; font-family:"Segoe UI",sans-serif; background:var(--bg); color:var(--text); transition:0.35s; text-align:center; }
h1{ margin:18px 0; color:var(--accent); text-shadow:1px 1px 3px rgba(0,0,0,0.15); }
#controls{ margin:20px; display:flex; flex-wrap:wrap; gap:10px; justify-content:center; align-items:center; }
input,select,button{ padding:10px 14px; font-size:14px; border-radius:8px; border:1px solid #ccc; }
button{ background:var(--accent); color:#fff; border:none; cursor:pointer; box-shadow:0 3px 6px var(--shadow); }
#topSummary { max-width:1100px; margin:10px auto; background:var(--card); padding:12px 16px; border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,0.06); text-align:left; font-size:0.95rem; }
#networks { display:flex; gap:12px; justify-content:center; align-items:flex-start; width:95%; margin:10px auto; }
.networkCard { flex:1; min-width:300px; background:var(--card); border-radius:12px; padding:10px; box-shadow:0 10px 24px rgba(0,0,0,0.04); position:relative; overflow:hidden; }
.networkHeader { font-weight:600; color:var(--accent); margin-bottom:8px; text-align:left; }
#leftNet, #rightNet { width:100%; height:520px; border-radius:10px; background:transparent; }
#status{ margin:10px; font-weight:500; min-height:20px; }
#spinner{ display:none; border:4px solid #f3f3f3; border-top:4px solid var(--accent); border-radius:50%; width:30px; height:30px; margin:6px auto; animation:spin 1s linear infinite; }
@keyframes spin{ to{ transform:rotate(360deg); } }
#notes{ background: rgba(43,78,255,0.07); padding:12px; border-radius:10px; max-width:900px; margin:10px auto; font-size:0.9em; text-align:left; }
footer{ margin:25px 0; font-size:0.8em; color:gray; }
footer a{ color:var(--accent); text-decoration:none; }

/* small translucent hint in top-right corner of each network card */
.zoomHint {
  position: absolute;
  right: 12px;
  top: 12px;
  z-index: 40;
  background: rgba(255,255,255,0.75);
  padding: 6px 10px;
  border-radius: 8px;
  font-size: 12px;
  color: #333;
  box-shadow: 0 6px 18px rgba(0,0,0,0.06);
  pointer-events: none;
}
body.dark .zoomHint { background: rgba(20,20,20,0.65); color: #eee; }

/* left header color override (green) */
.leftHeader { color: #34A853 !important; }

/* info box */
.infoBox { position:absolute; left:12px; top:12px; z-index:60; display:none; max-width:420px; background:rgba(255,255,255,0.96); padding:10px 12px; border-radius:8px; box-shadow:0 8px 20px rgba(0,0,0,0.08); text-align:left; font-size:13px; }
body.dark .infoBox{ background:rgba(20,20,20,0.95); color:#eee; }

/* small centered title text above center node (subtle) */
.centerTitle {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  top: 142px; /* roughly above the center node region */
  z-index: 30;
  background: rgba(255,255,255,0.85);
  padding: 6px 10px;
  border-radius: 8px;
  font-size: 13px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.06);
  max-width: 640px;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
body.dark .centerTitle{ background: rgba(20,20,20,0.8); color: #eee; }

@media (max-width:980px){
  #networks { flex-direction:column; }
  #leftNet, #rightNet { height:420px; }
  .zoomHint { display:none; } /* hide hint on small screens */
  .centerTitle{ top:110px; font-size:12px; max-width:320px; }
}
</style>
</head>
<body>
  <h1>By Selim - AtÄ±f Zinciri GÃ¶rselleÅŸtirici</h1>

  <div id="controls">
    <input id="paperInput" placeholder="Makale DOI'si (Ã¶rn: 10.1109/5.771073)" style="width:420px">
    <button id="searchButton">Ara</button>
    <button id="sampleButton">ğŸ² Ã–rnek DOI</button>
    <select id="yearFilter">
      <option value="all">TÃ¼m YÄ±llar</option>
      <option value="2010">2010+</option>
      <option value="2015">2015+</option>
      <option value="2020">2020+</option>
    </select>
    <button id="savePng">ğŸ’¾ PNG</button>
    <button id="savePdf">ğŸ“„ PDF</button>
    <button id="themeBtn">ğŸŒ™ Gece Modu</button>
  </div>

  <div id="spinner"></div>
  <div id="status">HazÄ±r â€” DOI girip Ara'ya basÄ±n.</div>

  <div id="topSummary"> KÄ±sa Ã¶zet: <i>HenÃ¼z makale yÃ¼klenmedi.</i></div>

  <div class="centerTitle" id="centerTitle" style="display:none;"></div>

  <div id="networks">
    <div class="networkCard">
      <div class="networkHeader leftHeader">AtÄ±flar (Ana makaleye atÄ±f yapan makaleler) â€” YeÅŸil</div>
      <div class="zoomHint">ğŸ–±ï¸ Fare tekerleÄŸiyle yakÄ±nlaÅŸtÄ±rÄ±n Â· SÃ¼rÃ¼kleyin</div>
      <div id="leftNet"></div>
    </div>
    <div class="networkCard">
      <div class="networkHeader">KaynakÃ§alar (KÃ¶k makalenin kullandÄ±klarÄ±) â€” Mavi</div>
      <div class="zoomHint">ğŸ–±ï¸ Fare tekerleÄŸiyle yakÄ±nlaÅŸtÄ±rÄ±n Â· SÃ¼rÃ¼kleyin</div>
      <div id="rightNet"></div>
    </div>
  </div>

  <div class="infoBox" id="infoBox"></div>

  <div id="notes">
    ğŸ”¹ Sol: ana makaleye atÄ±f yapan Ã§alÄ±ÅŸmalar (citations).<br>
    ğŸ”¹ SaÄŸ: makalenin kaynakÃ§asÄ± (references). âš ï¸ **En fazla 50 kaynakÃ§a gÃ¶sterilir.**<br>
    ğŸ”¹ Ã–zet: Ã¶nce Semantic Scholar tercih edilir; saÄŸlamazsa OpenAlex kullanÄ±lÄ±r. Ã–zetler otomatik temizlenir.<br>
    ğŸ”¹ DÃ¼ÄŸÃ¼mlere tÄ±klayarak makale sayfasÄ±na gidebilirsiniz (Ã§ift tÄ±k).<br>
    ğŸ”¹ ToplarÄ±n bÃ¼yÃ¼klÃ¼k farkÄ±, makalelerin aldÄ±ÄŸÄ± atÄ±f sayÄ±sÄ±na gÃ¶redir (daha bÃ¼yÃ¼k top = daha Ã§ok atÄ±f).<br>
  </div>

  <footer>Â© 2025 <b>Selim Ã–MÃœR</b> â€” <a href="mailto:omurselim@gmail.com">omurselim@gmail.com</a> â€” Ä°zinsiz kullanÄ±lamaz.</footer>

<script>
/* Yeni, tam sÃ¼rÃ¼m:
   - KaynakÃ§a limiti = 50
   - Semantic Scholar Ã¶ncelikli; references yoksa OpenAlex fallback (referenced_works)
   - Abstract temizleme ve OpenAlex fallback for abstract
   - Merkezi dÃ¼ÄŸÃ¼m kÃ¼Ã§Ã¼k baÅŸlÄ±k (centerTitle) gÃ¶sterme
   - Oklar daha gÃ¶rÃ¼nÃ¼r
*/

const PROXY = 'https://api.allorigins.win/raw?url='; // proxy for SS
const SS_TIMEOUT = 3500; // ms
const OX_REF_LIMIT = 50; // <--- KullanÄ±cÄ±nÄ±n istediÄŸi limit: 50
const CACHE = new Map();

function timeoutPromise(ms) { return new Promise((_, rej) => setTimeout(()=>rej(new Error('timeout')), ms)); }

// node size from citation count
function sizeFromCitations(count){
  const c = Math.max(0, Number(count)||0);
  return Math.round(6 + Math.sqrt(c) * 4);
}

// fetch via allorigins proxy (for Semantic Scholar)
async function fetchJsonProxy(url){
  const attempt = PROXY + encodeURIComponent(url);
  const controller = new AbortController();
  const id = setTimeout(()=>controller.abort(), 12000);
  try{
    const res = await fetch(attempt, { signal: controller.signal });
    clearTimeout(id);
    if(!res.ok) throw new Error('HTTP ' + res.status);
    const txt = await res.text();
    if(!txt) throw new Error('Empty response from proxy');
    return JSON.parse(txt);
  } catch(e){
    clearTimeout(id);
    throw e;
  }
}

// OpenAlex by DOI
async function fetchOpenAlex(doi){
  const url = `https://api.openalex.org/works/https://doi.org/${encodeURIComponent(doi)}`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('OpenAlex HTTP ' + res.status);
  return await res.json();
}

// fetch referenced_works ids for OpenAlex work (limit OX_REF_LIMIT)
async function fetchOpenAlexReferencedWorks(openalexWorkId, per_page = OX_REF_LIMIT){
  try{
    const seg = openalexWorkId.split('/').pop();
    const url = `https://api.openalex.org/works/${encodeURIComponent(seg)}/referenced_works?per_page=${per_page}`;
    const res = await fetch(url);
    if(!res.ok) return [];
    const j = await res.json();
    return (j.results || []).map(r => r.id);
  } catch(e){
    console.warn('fetchOpenAlexReferencedWorks fail', e);
    return [];
  }
}

async function fetchOpenAlexWorkById(openalexWorkId){
  try{
    const seg = openalexWorkId.split('/').pop();
    const url = `https://api.openalex.org/works/${encodeURIComponent(seg)}`;
    const res = await fetch(url);
    if(!res.ok) return null;
    return await res.json();
  }catch(e){ return null; }
}

// convert OpenAlex inverted abstract index to string
function openAlexAbstractToText(inv){
  try{
    if(!inv) return null;
    let maxPos = -1;
    for(const w in inv){ const arr = inv[w]; if(Array.isArray(arr)) arr.forEach(p => { if(p > maxPos) maxPos = p; }); }
    const out = new Array(maxPos+1);
    for(const w in inv){ const arr = inv[w]; if(Array.isArray(arr)) arr.forEach(pos => { out[pos] = w; }); }
    return out.filter(Boolean).join(' ');
  }catch(e){ return null; }
}

// strong cleaning for abstracts: remove urls, weird tokens, multiple spaces, odd emojis, long numeric garbage
function cleanAbstract(s){
  if(!s) return null;
  try{
    let t = String(s);

    // If it's large HTML or weird text, strip tags
    t = t.replace(/<\/?[^>]+(>|$)/g, ' ');

    // remove URLs
    t = t.replace(/https?:\/\/\S+/gi, ' ');
    // remove email-like
    t = t.replace(/\S+@\S+\.\S+/g, ' ');
    // remove escape sequences like \n \t and duplicated backslashes
    t = t.replace(/\\n|\\r|\\t|\\\\/g, ' ');
    // remove long runs of punctuation / emojis (keep basic punctuation)
    t = t.replace(/[\p{Emoji_Presentation}\p{Extended_Pictographic}]+/gu, ' ');
    // remove control characters
    t = t.replace(/[\x00-\x1F\x7F]/g, ' ');
    // collapse whitespace
    t = t.replace(/\s+/g, ' ').trim();
    // remove repeated short tokens like "â€¦", "â€”" excessive
    t = t.replace(/â€¦+/g, 'â€¦');
    // if the text contains nonsense patterns like "Wales vs Iran" with many time tokens from scraped web, try to trim to first 600 chars
    if(t.length > 1200) t = t.slice(0, 1200) + 'â€¦';
    // final safety: if still contains many non-letter characters, remove sequences longer than 30 of non-space
    t = t.replace(/\S{200,}/g, ' ');
    t = t.replace(/\s+/g, ' ').trim();

    if(t.length === 0) return null;
    return t;
  }catch(e){
    return s;
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const input = document.getElementById('paperInput');
  const searchButton = document.getElementById('searchButton');
  const sampleButton = document.getElementById('sampleButton');
  const spinner = document.getElementById('spinner');
  const status = document.getElementById('status');
  const leftEl = document.getElementById('leftNet');
  const rightEl = document.getElementById('rightNet');
  const topSummary = document.getElementById('topSummary');
  const savePng = document.getElementById('savePng');
  const savePdf = document.getElementById('savePdf');
  const themeBtn = document.getElementById('themeBtn');
  const yearFilter = document.getElementById('yearFilter');
  const infoBox = document.getElementById('infoBox');
  const centerTitle = document.getElementById('centerTitle');

  let leftNetwork = null, rightNetwork = null;
  let leftGraph = null, rightGraph = null;
  let currentData = null;

  themeBtn.onclick = ()=> { document.body.classList.toggle('dark'); themeBtn.textContent = document.body.classList.contains('dark') ? 'â˜€ï¸' : 'ğŸŒ™'; };

  sampleButton.onclick = () => { input.value = '10.1109/5.771073'; searchPaper(); };
  input.addEventListener('keyup', e => { if(e.key==='Enter') searchPaper(); });
  searchButton.onclick = searchPaper;

  savePng.onclick = async () => {
    if(!leftNetwork && !rightNetwork) return alert('Ã–nce grafik oluÅŸturun!');
    const leftCanvas = leftNetwork ? leftNetwork.canvas.frame.canvas : null;
    const rightCanvas = rightNetwork ? rightNetwork.canvas.frame.canvas : null;
    const w = (leftCanvas?leftCanvas.width:0) + (rightCanvas?rightCanvas.width:0);
    const h = Math.max(leftCanvas?leftCanvas.height:0, rightCanvas?rightCanvas.height:0);
    const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
    const ctx = tmp.getContext('2d');
    if(leftCanvas) ctx.drawImage(leftCanvas, 0, 0);
    if(rightCanvas) ctx.drawImage(rightCanvas, leftCanvas?leftCanvas.width:0, 0);
    const a = document.createElement('a'); a.href = tmp.toDataURL('image/png'); a.download = 'atif-citations-references.png'; a.click();
  };

  savePdf.onclick = async () => {
    if(!leftNetwork && !rightNetwork) return alert('Ã–nce grafik oluÅŸturun!');
    const leftCanvas = leftNetwork ? leftNetwork.canvas.frame.canvas : null;
    const rightCanvas = rightNetwork ? rightNetwork.canvas.frame.canvas : null;
    const w = (leftCanvas?leftCanvas.width:0) + (rightCanvas?rightCanvas.width:0);
    const h = Math.max(leftCanvas?leftCanvas.height:0, rightCanvas?rightCanvas.height:0);
    const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
    const ctx = tmp.getContext('2d');
    if(leftCanvas) ctx.drawImage(leftCanvas, 0, 0);
    if(rightCanvas) ctx.drawImage(rightCanvas, leftCanvas?leftCanvas.width:0, 0);
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation: 'landscape' });
    const img = tmp.toDataURL('image/png');
    const pw = pdf.internal.pageSize.getWidth(), ph = pdf.internal.pageSize.getHeight();
    pdf.addImage(img, 'PNG', 10, 10, pw-20, ph-20);
    pdf.save('atif-citations-references.pdf');
  };

  async function searchPaper(){
    const doi = input.value.trim();
    if(!doi){ status.textContent = 'âš ï¸ LÃ¼tfen DOI girin.'; return; }
    if(CACHE.has(doi)){
      currentData = CACHE.get(doi);
      renderAll(currentData);
      status.textContent = 'âš¡ Ã–nbellekten yÃ¼klendi.';
      return;
    }

    spinner.style.display = 'inline-block';
    status.textContent = 'ğŸ” Veriler Ã§ekiliyor (Semantic Scholar Ã¶ncelikli, OpenAlex fallback)...';
    topSummary.innerHTML = 'KÄ±sa Ã¶zet: <i>YÃ¼kleniyor...</i>';
    centerTitle.style.display = 'none';
    centerTitle.textContent = '';

    // parallel fetch attempts
    const ssPromise = (async ()=> {
      try{
        const url = `https://api.semanticscholar.org/graph/v1/paper/DOI:${encodeURIComponent(doi)}?fields=title,year,authors,doi,paperId,url,citationCount,abstract,references.paperId,references.title,references.year,references.doi,citations.paperId,citations.title,citations.year,citations.doi`;
        return await fetchJsonProxy(url);
      }catch(e){ console.warn('SS fail', e); return null; }
    })();

    const oxPromise = (async ()=> {
      try{ return await fetchOpenAlex(doi); }catch(e){ console.warn('OX fail', e); return null; }
    })();

    let ssResult = null, oxResult = null;
    try {
      ssResult = await Promise.race([ ssPromise, timeoutPromise(SS_TIMEOUT).then(()=>{ throw new Error('ss-timeout'); }) ]).catch(e=>{ console.warn('ss race err', e); return null; });
    } catch(e){ ssResult = null; }
    try { oxResult = await Promise.race([ oxPromise, timeoutPromise(SS_TIMEOUT).then(()=>null) ]); } catch(e){ oxResult = null; }

    if(!ssResult && !oxResult){
      try{ ssResult = await ssPromise; } catch(e){ ssResult = ssResult || null; }
      try{ oxResult = await oxPromise; } catch(e){ oxResult = oxResult || null; }
    }

    let finalData = null;

    // If Semantic Scholar returned usable info (citations or references), prefer it
    if(ssResult && ( (Array.isArray(ssResult.citations) && ssResult.citations.length>0) || (Array.isArray(ssResult.references) && ssResult.references.length>0) )){
      finalData = {
        source: 'ss',
        title: ssResult.title,
        year: ssResult.year,
        doi: ssResult.doi || doi,
        paperId: ssResult.paperId,
        url: ssResult.url || (ssResult.doi?`https://doi.org/${ssResult.doi}`:null),
        citationCount: ssResult.citationCount || 0,
        abstract: cleanAbstract(ssResult.abstract || null),
        references: (ssResult.references || []).map(r => ({
          title: r.title || r.reference?.title || 'BaÅŸlÄ±k',
          paperId: r.paperId || (r.reference && r.reference.paperId) || r.reference?.doi || null,
          doi: r.doi || r.reference?.doi || null,
          year: r.year || r.reference?.year || null,
          citationCount: r.citationCount || r.reference?.citationCount || 0,
          url: null
        })),
        citations: (ssResult.citations || []).map(c => ({
          title: c.title || c.citingPaper?.title || 'BaÅŸlÄ±k',
          paperId: c.paperId || c.citingPaper?.paperId || c.citingPaper?.doi || null,
          doi: c.doi || c.citingPaper?.doi || null,
          year: c.year || c.citingPaper?.year || null,
          citationCount: c.citationCount || c.citingPaper?.citationCount || 0,
          url: null
        }))
      };

      // Ensure references list is capped to OX_REF_LIMIT
      if(finalData.references.length > OX_REF_LIMIT) {
        finalData.references = finalData.references.slice(0, OX_REF_LIMIT);
      }

      // --------------------------------------------------------------------
      // --- Ä°ÅTE DÃœZELTME BURADA ---
      // If SS references empty or INSUFFICIENT (e.g. sample < 20), fallback to OpenAlex referenced_works
      // ESKÄ° HALÄ°: (!finalData.references || finalData.references.length === 0)
      // YENÄ° HALÄ°: (!finalData.references || finalData.references.length < 20)
      // --------------------------------------------------------------------
      if((!finalData.references || finalData.references.length < 20) && oxResult && oxResult.id){
        try{
          const refIds = await fetchOpenAlexReferencedWorks(oxResult.id, OX_REF_LIMIT);
          const fetched = [];
          for(let i=0;i<refIds.length;i+=25){
            const chunk = refIds.slice(i,i+25);
            const p = await Promise.all(chunk.map(id => fetchOpenAlexWorkById(id).catch(()=>null)));
            p.forEach(r => { if(r) fetched.push({ title: r.title, paperId: r.id, doi: r.doi||null, year: r.publication_year||null, citationCount: r.cited_by_count||0, url: r.primary_location?.source_url||null }); });
            await new Promise(r=>setTimeout(r,120));
          }
          if(fetched.length>0){
            finalData.references = fetched.slice(0, OX_REF_LIMIT);
            status.textContent += ` (OpenAlex fallback ile ${finalData.references.length} kaynakÃ§a eklendi â€” limit ${OX_REF_LIMIT})`;
          }
        }catch(e){ console.warn('fallback refs failed', e); }
      }

      // If SS abstract seems broken (very short or contains obvious scraped content), try OpenAlex abstract
      if((!finalData.abstract || finalData.abstract.length < 30) && oxResult && oxResult.abstract_inverted_index){
        const oxAbs = openAlexAbstractToText(oxResult.abstract_inverted_index);
        const cleaned = cleanAbstract(oxAbs);
        if(cleaned && cleaned.length > (finalData.abstract?finalData.abstract.length:0)){
          finalData.abstract = cleaned;
        }
      }

    } else if(oxResult && oxResult.id){
      // Build entirely from OpenAlex when SS lacks
      const base = {
        source: 'ox',
        title: oxResult.title,
        year: oxResult.publication_year,
        doi: doi,
        paperId: oxResult.id,
        url: oxResult.open_access?.oa_url || `https://openalex.org/${oxResult.id.split('/').pop()}`,
        citationCount: oxResult.cited_by_count || 0,
        abstract: cleanAbstract(oxResult.abstract || openAlexAbstractToText(oxResult.abstract_inverted_index) || null),
        references: [],
        citations: []
      };

      try{
        const refIds = await fetchOpenAlexReferencedWorks(oxResult.id, OX_REF_LIMIT);
        for(let i=0;i<refIds.length;i+=25){
          const chunk = refIds.slice(i,i+25);
          const promises = chunk.map(id => fetchOpenAlexWorkById(id).catch(()=>null));
          const results = await Promise.all(promises);
          results.forEach(r => { if(r) base.references.push({ title: r.title, paperId: r.id, doi: r.doi||null, year: r.publication_year||null, citationCount: r.cited_by_count||0, url: r.primary_location?.source_url || null }); });
          await new Promise(r=>setTimeout(r,120));
        }
      }catch(e){ console.warn('openalex referenced fetch fail', e); }
      // citations from OpenAlex (may be many)
      try{
        const citesResp = await fetch(`https://api.openalex.org/works?filter=cites:${encodeURIComponent(oxResult.id)}&per_page=200`);
        if(citesResp.ok){
          const cj = await citesResp.json();
          (cj.results || []).forEach(r => base.citations.push({ title: r.title, paperId: r.id, doi: r.doi||null, year: r.publication_year||null, citationCount: r.cited_by_count||0, url: r.primary_location?.source_url || null }));
        }
      }catch(e){ console.warn('openalex cites fetch fail', e); }
      finalData = base;
    } else if(ssResult){
      // minimal SS fallback
      finalData = {
        source: 'ss_min',
        title: ssResult.title,
        year: ssResult.year,
        doi: ssResult.doi || doi,
        paperId: ssResult.paperId,
        url: ssResult.url || (ssResult.doi?`https://doi.org/${ssResult.doi}`:null),
        citationCount: ssResult.citationCount || 0,
        abstract: cleanAbstract(ssResult.abstract || null),
        references: (ssResult.references || []).map(r => ({ title: r.title || r.reference?.title || 'BaÅŸlÄ±k', paperId: r.paperId || r.reference?.paperId || null, doi: r.doi || r.reference?.doi || null, year: r.year || r.reference?.year || null, citationCount: r.citationCount || r.reference?.citationCount || 0, url: null })),
        citations: (ssResult.citations || []).map(c => ({ title: c.title || c.citingPaper?.title || 'BaÅŸlÄ±k', paperId: c.paperId || c.citingPaper?.paperId || null, doi: c.doi || c.citingPaper?.doi || null, year: c.year || c.citingPaper?.year || null, citationCount: c.citationCount || c.citingPaper?.citationCount || 0, url: null }))
      };
      if(finalData.references.length > OX_REF_LIMIT) finalData.references = finalData.references.slice(0, OX_REF_LIMIT);
    } else {
      spinner.style.display = 'none';
      status.textContent = 'âŒ Veri alÄ±namadÄ±: Kaynaklar yanÄ±t vermedi.';
      topSummary.innerHTML = 'KÄ±sa Ã¶zet: <i>Ã–zet alÄ±namadÄ±.</i>';
      return;
    }

    // ensure references capped to OX_REF_LIMIT (safety)
    if(finalData.references && finalData.references.length > OX_REF_LIMIT){
      finalData.references = finalData.references.slice(0, OX_REF_LIMIT);
    }

    // cache & render
    CACHE.set(doi, finalData);
    currentData = finalData;
    renderAll(finalData);
    spinner.style.display = 'none';
    status.textContent = `âœ… "${finalData.title || doi}" yÃ¼klendi. (refs: ${finalData.references.length}, cits: ${finalData.citations.length})`;
  } // end searchPaper

  // render everything
  function renderAll(data){
    const abs = data.abstract ? (data.abstract.length>700 ? data.abstract.slice(0,700)+'â€¦' : data.abstract) : '<i>Ã–zet bulunamadÄ±.</i>';
    topSummary.innerHTML = `<strong>${data.title || ''}</strong> (${data.year || '?'})<br><small>${abs}</small>`;

    // show small centered title above main area
    if(data.title){
      centerTitle.style.display = 'block';
      centerTitle.textContent = (data.title.length>120? data.title.slice(0,120)+'â€¦' : data.title);
    } else {
      centerTitle.style.display = 'none';
    }

    const yearLimit = yearFilter.value === 'all' ? 0 : parseInt(yearFilter.value);
    const citList = (data.citations||[]).filter(x => !(x.year && yearLimit && x.year < yearLimit));
    const refList = (data.references||[]).filter(x => !(x.year && yearLimit && x.year < yearLimit));

    drawNetworkLeft(citList, data);
    drawNetworkRight(refList, data);
  }

  function chooseLabelledNodes(list){
    const n = list.length;
    if(n === 0) return new Set();
    const k = Math.max(10, Math.round(n * 0.12)); // top 12% or at least 10 (less aggressive)
    const sorted = [...list].sort((a,b)=> (Number(b.citationCount||0) - Number(a.citationCount||0)));
    const top = sorted.slice(0,k).map(x => x.paperId || x.id || x.doi || x.title);
    return new Set(top);
  }

  function drawNetworkLeft(citations, data){
    const nodes = [], edges = [];
    const mainId = data.paperId || data.doi || 'main';
    // central node label - single-line short title to avoid overlap
    const centralShort = (data.title || '').split('\n')[0].slice(0,40) + (data.title && data.title.length>40? 'â€¦' : '');
    nodes.push({ id: mainId, label: centralShort, title: `${data.title||''}\n(${data.year||'?'})`, color:'#f0a30a', size: sizeFromCitations(data.citationCount||0), url: data.url, citationCount: data.citationCount||0 });

    const labelledSet = chooseLabelledNodes(citations);
    let maxCitation = 0;
    citations.forEach(it => { const c = Number(it.citationCount||0); if(c>maxCitation) maxCitation = c; });

    citations.forEach(item=>{
      const id = item.paperId || item.doi || (item.title + '::' + Math.random().toString(36).slice(2,6));
      const showLabel = labelledSet.has(item.paperId || item.doi || id);
      nodes.push({ id, label: showLabel ? (item.title||'').substring(0,40) : '', title:`${item.title||''}\nYÄ±l:${item.year||'?'}`, color:'#34A853', size: sizeFromCitations(item.citationCount||0), url: item.doi?`https://doi.org/${item.doi}`: item.url || null, citationCount: item.citationCount||0 });
      edges.push({ from: id, to: mainId, color:{ color:'#34A853' }, arrows: { to: { enabled: true, type: 'arrow' } } });
    });

    const uniq = {}; nodes.forEach(n => uniq[n.id] = n);
    const finalNodes = Object.values(uniq);
    const gdata = { nodes: new vis.DataSet(finalNodes), edges: new vis.DataSet(edges) };

    if(leftNetwork) leftNetwork.destroy();
    leftNetwork = new vis.Network(leftEl, gdata, {
      nodes:{ shape:'dot', font:{ size:10, color: 'var(--text)' } },
      edges:{ width:2.6, smooth:{ type:'dynamic' }, arrows:{ to:{ enabled:true, scaleFactor:1.2, type:'arrow' } } },
      physics:{ stabilization:false, barnesHut:{ gravitationalConstant:-2400, springLength:120, springConstant:0.02 } },
      interaction:{ hover:true, hoverConnectedEdges: true, navigationButtons:true, zoomView:true }
    });

    leftGraph = gdata;
    leftNetwork.body.data._maxCitation = maxCitation;

    leftNetwork.on('stabilizationIterationsDone', ()=> { try{ leftNetwork.physics.stop(); }catch(e){} });
    leftNetwork.on('click', params => {
      if(params.nodes.length){
        const node = leftGraph.nodes.get(params.nodes[0]);
        showInfo(node);
      } else hideInfo();
    });
    leftNetwork.on('doubleClick', params => { if(params.nodes.length){ const node = leftGraph.nodes.get(params.nodes[0]); if(node && node.url) window.open(node.url,'_blank'); } });

    leftNetwork.on('hoverNode', params => {
      const n = leftGraph.nodes.get(params.node);
      if(n && !n.label) leftGraph.nodes.update({ id: n.id, label: (n.title||'').split('\n')[0].slice(0,40) });
      if(n && Number(n.citationCount||0) === leftNetwork.body.data._maxCitation && leftNetwork.body.data._maxCitation>0){
        infoBox.style.display = 'block';
        infoBox.style.left = (leftEl.getBoundingClientRect().left + 12) + 'px';
        infoBox.style.top = (leftEl.getBoundingClientRect().top + 12) + 'px';
        infoBox.innerHTML = `<strong>Bu makale en fazla atÄ±f alan kaynaktÄ±r.</strong><br>${(n.title||'').split('\n')[0]}<br>AtÄ±f sayÄ±sÄ±: ${n.citationCount || 0}`;
      }
    });

    leftNetwork.on('blurNode', params => {
      const n = leftGraph.nodes.get(params.node);
      if(n){
        const shouldHave = labelledSet.has(n.id);
        if(!shouldHave) leftGraph.nodes.update({ id: n.id, label: '' });
      }
      hideInfo();
    });
  }

  function drawNetworkRight(references, data){
    const nodes = [], edges = [];
    const mainId = data.paperId || data.doi || 'main';
    const centralShort = (data.title || '').split('\n')[0].slice(0,40) + (data.title && data.title.length>40? 'â€¦' : '');
    nodes.push({ id: mainId, label: centralShort, title: `${data.title||''}\n(${data.year||'?'})`, color:'#f0a30a', size: sizeFromCitations(data.citationCount||0), url: data.url, citationCount: data.citationCount||0 });

    const labelledSet = chooseLabelledNodes(references);
    let maxCitation = 0;
    references.forEach(it => { const c = Number(it.citationCount||0); if(c>maxCitation) maxCitation = c; });

    references.forEach(item=>{
      const id = item.paperId || item.doi || (item.title + '::' + Math.random().toString(36).slice(2,6));
      const showLabel = labelledSet.has(item.paperId || item.doi || id);
      nodes.push({ id, label: showLabel ? (item.title||'').substring(0,40) : '', title:`${item.title||''}\nYÄ±l:${item.year||'?'}`, color:'#4285F4', size: sizeFromCitations(item.citationCount||0), url: item.doi?`https://doi.org/${item.doi}`: item.url || null, citationCount: item.citationCount||0 });
      edges.push({ from: mainId, to: id, color:{ color:'#4285F4' }, arrows: { to: { enabled: true, type: 'arrow' } } });
    });

    const uniq = {}; nodes.forEach(n => uniq[n.id] = n);
    const finalNodes = Object.values(uniq);
    const gdata = { nodes: new vis.DataSet(finalNodes), edges: new vis.DataSet(edges) };

    if(rightNetwork) rightNetwork.destroy();
    rightNetwork = new vis.Network(rightEl, gdata, {
      nodes:{ shape:'dot', font:{ size:10, color: 'var(--text)' } },
      edges:{ width:2.6, smooth:{ type:'dynamic' }, arrows:{ to:{ enabled:true, scaleFactor:1.2, type:'arrow' } } },
      physics:{ stabilization:false, barnesHut:{ gravitationalConstant:-2200, springLength:120, springConstant:0.02 } },
      interaction:{ hover:true, hoverConnectedEdges: true, navigationButtons:true, zoomView:true }
    });

    rightGraph = gdata;
    rightNetwork.body.data._maxCitation = maxCitation;

    rightNetwork.on('stabilizationIterationsDone', ()=> { try{ rightNetwork.physics.stop(); }catch(e){} });
    rightNetwork.on('click', params => {
      if(params.nodes.length){
        const node = rightGraph.nodes.get(params.nodes[0]);
        showInfo(node);
      } else hideInfo();
    });
    rightNetwork.on('doubleClick', params => { if(params.nodes.length){ const node = rightGraph.nodes.get(params.nodes[0]); if(node && node.url) window.open(node.url,'_blank'); } });

    rightNetwork.on('hoverNode', params => {
      const n = rightGraph.nodes.get(params.node);
      if(n && !n.label) rightGraph.nodes.update({ id: n.id, label: (n.title||'').split('\n')[0].slice(0,40) });
      if(n && Number(n.citationCount||0) === rightNetwork.body.data._maxCitation && rightNetwork.body.data._maxCitation>0){
        infoBox.style.display = 'block';
        infoBox.style.left = (rightEl.getBoundingClientRect().left + 12) + 'px';
        infoBox.style.top = (rightEl.getBoundingClientRect().top + 12) + 'px';
        infoBox.innerHTML = `<strong>Bu makale en fazla atÄ±f alan kaynaktÄ±r.</strong><br>${(n.title||'').split('\n')[0]}<br>AtÄ±f sayÄ±sÄ±: ${n.citationCount || 0}`;
      }
    });

    rightNetwork.on('blurNode', params => {
      const n = rightGraph.nodes.get(params.node);
      if(n){
        const shouldHave = labelledSet.has(n.id);
        if(!shouldHave) leftGraph.nodes.update({ id: n.id, label: '' });
      }
      hideInfo();
    });
  }

  function showInfo(node){
    if(!node) return;
    infoBox.style.display = 'block';
    infoBox.style.left = '12px';
    infoBox.style.top = '12px';
    infoBox.innerHTML = `<strong>${(node.label && node.label.length>0)?node.label:(node.title||'BaÅŸlÄ±k').split('\n')[0]}</strong><br>${(node.title||'')}<br>${node.url? `<a href="${node.url}" target="_blank">Makale sayfasÄ±</a>` : ''}`;
  }
  function hideInfo(){ infoBox.style.display = 'none'; }

  yearFilter.addEventListener('change', ()=>{ if(currentData) renderAll(currentData); });

  // quick debug trigger
  window.searchPaper = () => { document.getElementById('searchButton').click(); };

}); // DOMContentLoaded end
</script>
</body>
</html>
