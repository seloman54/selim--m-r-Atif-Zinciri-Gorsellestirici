<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>By Selim - AtÄ±f Zinciri GÃ¶rselleÅŸtirici</title>

  <!-- vis.js -->
  <script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css" />

  <!-- html2canvas + jspdf -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    :root {
      --bg: linear-gradient(135deg,#f7f9ff,#e9eeff);
      --accent:#2b4eff; --shadow: rgba(43,78,255,0.15);
      --card:#fff; --text:#111;
    }
    body.dark{ --bg: linear-gradient(135deg,#0f1116,#1a1d23); --accent:#00bfff; --card:#1f1f1f; --text:#eee; --shadow: rgba(0,191,255,0.18); }
    body{ margin:0; font-family:"Segoe UI",sans-serif; background:var(--bg); color:var(--text); transition:0.35s; text-align:center; }
    h1{ margin:18px 0; color:var(--accent); text-shadow:1px 1px 3px rgba(0,0,0,0.15); }
    #controls{ margin:20px; display:flex; flex-wrap:wrap; justify-content:center; gap:10px; }
    input,select,button{ padding:10px 14px; font-size:14px; border-radius:8px; border:1px solid #ccc; }
    button{ background:var(--accent); color:#fff; border:none; cursor:pointer; box-shadow:0 3px 6px var(--shadow); }
    #network{ width:90%; height:550px; background:var(--card); margin:0 auto; border-radius:15px; box-shadow:0 0 25px var(--shadow); position:relative; }
    #status{ margin:10px; font-weight:500; min-height:20px; }
    #spinner{ display:none; border:4px solid #f3f3f3; border-top:4px solid var(--accent); border-radius:50%; width:30px; height:30px; margin:10px auto; animation:spin 1s linear infinite; }
    @keyframes spin{ to{ transform:rotate(360deg); } }
    #notes{ background: rgba(43,78,255,0.07); padding:12px; border-radius:10px; max-width:700px; margin:10px auto; font-size:0.9em; text-align:left; }
    footer{ margin:25px 0; font-size:0.8em; color:gray; opacity:0.9; }
    footer a{ color:var(--accent); text-decoration:none; }
    #centerButton{ position:absolute; right:10px; top:10px; z-index:10; padding:6px 10px; border-radius:8px; border:none; background:var(--accent); color:#fff; cursor:pointer; }
    #infoBox{ position:absolute; left:12px; top:12px; z-index:10; background:rgba(255,255,255,0.95); padding:8px 10px; border-radius:8px; display:none; box-shadow:0 4px 12px rgba(0,0,0,0.08); font-size:13px; max-width:320px; text-align:left; }
    body.dark #infoBox{ background:rgba(30,30,30,0.92); color:#eee; }
    @media (max-width:720px){ #network{ height:440px; } input{ width:200px; } }
  </style>
</head>
<body>
  <h1>By Selim - AtÄ±f Zinciri GÃ¶rselleÅŸtirici</h1>

  <div id="controls">
    <input id="paperInput" placeholder="Makale DOI'si (Ã¶rn: 10.1109/5.771073)" style="width:360px" />
    <button id="searchButton">Ara</button>
    <button id="sampleButton">ðŸŽ² Ã–rnek DOI</button>
    <select id="yearFilter">
      <option value="all">TÃ¼m YÄ±llar</option>
      <option value="2010">2010+</option>
      <option value="2015">2015+</option>
      <option value="2020">2020+</option>
    </select>
    <button id="savePNG">ðŸ’¾ GrafiÄŸi Kaydet</button>
    <button id="savePDF">ðŸ“„ PDF</button>
    <button id="themeButton">ðŸŒ™ Gece Modu</button>
  </div>

  <div id="spinner"></div>
  <div id="status">HazÄ±r â€” DOI girip Ara'ya basÄ±n.</div>

  <div id="network">
    <div id="infoBox"></div>
    <button id="centerButton">ðŸŽ¯ Ortala</button>
  </div>

  <div id="notes">
    ðŸ”¹ Mavi dÃ¼ÄŸÃ¼mler kaynakÃ§a, yeÅŸiller atÄ±f yapan makalelerdir.<br>
    ðŸ”¹ DÃ¼ÄŸÃ¼mlere tÄ±klayarak makale sayfasÄ±na gidebilirsiniz (Ã§ift tÄ±k).<br>
    ðŸ”¹ DÃ¼ÄŸÃ¼mler atÄ±f sayÄ±sÄ±na gÃ¶re boyutlanÄ±r: <code>size = 5 + Math.sqrt(citationCount) * 4</code>.<br>
    ðŸ”¹ EÄŸer veri gelmezse (proxy sorunlarÄ±) konsol (F12 â†’ Console) Ã§Ä±ktÄ±sÄ±nÄ± gÃ¶nder; hemen dÃ¼zenleyeyim.
  </div>

  <footer>
    Â© 2025 <b>Selim Ã–MÃœR</b> | <a href="mailto:omurselim@gmail.com">omurselim@gmail.com</a> | Ä°zinsiz kullanÄ±lamaz.
  </footer>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const paperInput = document.getElementById('paperInput');
  const searchButton = document.getElementById('searchButton');
  const sampleButton = document.getElementById('sampleButton');
  const yearFilter = document.getElementById('yearFilter');
  const spinner = document.getElementById('spinner');
  const status = document.getElementById('status');
  const container = document.getElementById('network');
  const infoBox = document.getElementById('infoBox');
  const centerButton = document.getElementById('centerButton');
  const savePNG = document.getElementById('savePNG');
  const savePDF = document.getElementById('savePDF');
  const themeButton = document.getElementById('themeButton');

  // proxy list: direct first, then a few proxies
  const PROXIES = [
    '', // direct
    'https://api.allorigins.win/raw?url=',
    'https://thingproxy.freeboard.io/fetch/',
    'https://corsproxy.io/?',
    'https://cors.isomorphic-git.org/',
  ];

  let network = null;
  let graphData = null;

  const visOptions = {
    nodes: { shape: 'dot', font: { size: 14 } },
    edges: { width: 2, smooth: { type: 'dynamic', roundness: 0.3 }, arrows: { to: { enabled: true, scaleFactor: 0.6 } } },
    physics: { stabilization: true, solver: 'barnesHut', barnesHut: { gravitationalConstant: -2000 } },
    interaction: { hover: true }
  };

  themeButton.onclick = () => {
    document.body.classList.toggle('dark');
    themeButton.textContent = document.body.classList.contains('dark') ? 'â˜€ï¸ GÃ¼ndÃ¼z Modu' : 'ðŸŒ™ Gece Modu';
    infoBox.classList.toggle('dark');
  };

  sampleButton.onclick = () => {
    const samples = ["10.1109/5.771073","10.1038/nature12373","10.48550/arXiv.1706.03762","10.1145/3368089.3409694"];
    paperInput.value = samples[Math.floor(Math.random()*samples.length)];
    searchPaper();
  };

  paperInput.addEventListener('keyup', e => { if(e.key === 'Enter') searchPaper(); });
  searchButton.onclick = searchPaper;

  savePNG.onclick = () => {
    if(!network) return alert('Ã–nce grafik oluÅŸturun!');
    const canvas = network.canvas.frame.canvas;
    const a = document.createElement('a');
    a.href = canvas.toDataURL('image/png');
    a.download = 'atif-grafik.png';
    a.click();
  };

  savePDF.onclick = () => {
    if(!network) return alert('Ã–nce grafik oluÅŸturun!');
    const canvas = network.canvas.frame.canvas;
    const imgData = canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation: 'landscape' });
    const w = pdf.internal.pageSize.getWidth();
    const h = pdf.internal.pageSize.getHeight();
    pdf.addImage(imgData, 'PNG', 10, 10, w-20, h-20);
    pdf.save('atif-grafik.pdf');
  };

  centerButton.onclick = () => { if(network) network.fit({ animation: { duration: 600 } }); };

  // safe fetch: try multiple proxies, return parsed JSON or null
  async function tryFetchJson(url, timeout = 12000) {
    let lastError = null;
    for(const p of PROXIES) {
      const attempt = p ? (p + encodeURIComponent(url)) : url;
      try {
        const controller = new AbortController();
        const id = setTimeout(()=>controller.abort(), timeout);
        const res = await fetch(attempt, { signal: controller.signal });
        clearTimeout(id);
        if(!res.ok) {
          lastError = new Error(`HTTP ${res.status} from ${attempt}`);
          console.warn('tryFetchJson non-ok', lastError);
          continue;
        }
        // get text first (avoids Unexpected end of JSON input)
        const txt = await res.text();
        if(!txt) {
          lastError = new Error('Empty response text from ' + attempt);
          console.warn(lastError);
          continue;
        }
        try {
          const j = JSON.parse(txt);
          return j;
        } catch(parseErr) {
          // Not JSON? return text (some proxies may return HTML)
          console.warn('parse failed from', attempt, parseErr);
          lastError = parseErr;
          continue;
        }
      } catch(err) {
        lastError = err;
        console.warn('fetch attempt failed', attempt, err);
        // try next proxy
      }
    }
    throw lastError || new Error('All proxies failed');
  }

  // size formula deterministic
  function sizeFromCitations(count) {
    const c = Math.max(0, Number(count) || 0);
    return Math.round(5 + Math.sqrt(c) * 4);
  }

  // get semantic scholar main + paged refs & cits
  async function searchPaper() {
    const doi = paperInput.value.trim();
    if(!doi) { status.textContent = 'âš ï¸ LÃ¼tfen DOI girin.'; return; }
    status.textContent = 'ðŸ” Veri Ã§ekiliyor...';
    spinner.style.display = 'inline-block';

    try {
      const mainUrl = `https://api.semanticscholar.org/graph/v1/paper/DOI:${encodeURIComponent(doi)}?fields=title,year,authors,doi,paperId,url,citationCount`;
      const main = await tryFetchJson(mainUrl).catch(e => { console.warn('main fetch failed', e); return null; });
      // if main exists and has paperId, fetch paginated
      let data = null;
      if(main && main.paperId) {
        // fetch references & citations pages
        const refsEndpoint = `https://api.semanticscholar.org/graph/v1/paper/${encodeURIComponent(main.paperId)}/references?fields=reference.paperId,reference.title,reference.year,reference.doi,reference.citationCount`;
        const citsEndpoint = `https://api.semanticscholar.org/graph/v1/paper/${encodeURIComponent(main.paperId)}/citations?fields=citingPaper.paperId,citingPaper.title,citingPaper.year,citingPaper.doi,citingPaper.citationCount`;

        // helper to fetch pages
        async function fetchAllPages(endpoint){
          const all = [];
          const limit = 100;
          let offset = 0;
          while(true) {
            const pageUrl = `${endpoint}&limit=${limit}&offset=${offset}`;
            let j = await tryFetchJson(pageUrl).catch(e => { console.warn('page fetch failed', e); return null; });
            if(!j) break;
            const items = j.data || j.results || j.citations || j.references || [];
            if(!Array.isArray(items) || items.length === 0) break;
            items.forEach(it => {
              const unified = it.citingPaper || it.reference || it;
              if(unified) all.push(unified);
            });
            if(items.length < limit) break;
            offset += limit;
            await new Promise(r => setTimeout(r, 150));
            if(offset > 5000) break;
          }
          return all;
        }

        const [refs, cits] = await Promise.all([
          fetchAllPages(refsEndpoint).catch(()=>[]),
          fetchAllPages(citsEndpoint).catch(()=>[])
        ]);

        data = {
          title: main.title, year: main.year, doi: main.doi, paperId: main.paperId, url: main.url || (main.doi?`https://doi.org/${main.doi}`:null),
          citationCount: main.citationCount || 0,
          references: refs.map(r=>({ title: r.title||r.reference?.title||'BaÅŸlÄ±k', paperId: r.paperId||r.doi||null, doi: r.doi||null, year: r.year||null, citationCount: r.citationCount||0, url: r.url||null })),
          citations: cits.map(c=>{ const p = c.citingPaper||c; return { title: p.title||'BaÅŸlÄ±k', paperId: p.paperId||p.doi||null, doi: p.doi||null, year: p.year||null, citationCount: p.citationCount||0, url: p.url||null } })
        };
      }

      // fallback: if data missing or empty, try OpenAlex (direct â€” OpenAlex supports CORS)
      if(!data || (Array.isArray(data.references) && data.references.length===0 && Array.isArray(data.citations) && data.citations.length===0)) {
        try {
          const oxUrl = `https://api.openalex.org/works/https://doi.org/${encodeURIComponent(doi)}`;
          const ox = await tryFetchJson(oxUrl).catch(()=>null);
          if(ox && ox.id) {
            const d = { title: ox.title, year: ox.publication_year, doi: doi, paperId: ox.id, url: ox.open_access?.oa_url || `https://openalex.org/${ox.id.split('/').pop()}`, citationCount: ox.cited_by_count || 0, references: [], citations: [] };
            // fetch referenced works (limited to 200)
            const refs = (ox.referenced_works || []).slice(0,200);
            const refFetches = refs.map(id => tryFetchJson(id).catch(()=>null));
            const refsData = await Promise.all(refFetches);
            refsData.forEach(r => { if(r) d.references.push({ title: r.title, paperId: r.id, doi: r.doi||null, year: r.publication_year||null, citationCount: r.cited_by_count||0, url: r.primary_location?.source_url||null }); });
            // citing works
            const citesResp = await tryFetchJson(`https://api.openalex.org/works?filter=cites:${encodeURIComponent(ox.id)}&per_page=200`).catch(()=>null);
            if(citesResp && Array.isArray(citesResp.results)) citesResp.results.forEach(r => d.citations.push({ title: r.title, paperId: r.id, doi: r.doi||null, year: r.publication_year, citationCount: r.cited_by_count||0, url: r.primary_location?.source_url||null }));
            data = d;
          }
        } catch(e){ console.warn('OpenAlex fallback failed', e); }
      }

      if(!data) throw new Error('Veri alÄ±namadÄ± (Semantic Scholar & OpenAlex baÅŸarÄ±sÄ±z).');

      // draw
      drawGraph(data);
      status.textContent = `âœ… "${data.title}" gÃ¶sterildi. (refs: ${data.references.length}, cits: ${data.citations.length})`;
    } catch(err) {
      console.error('searchPaper error:', err);
      status.textContent = `âŒ Veri alÄ±namadÄ±: ${err.message || err}`;
    } finally {
      spinner.style.display = 'none';
    }
  }

  function drawGraph(data) {
    // preserve look & behavior you liked
    const yearLimit = yearFilter.value === 'all' ? 0 : parseInt(yearFilter.value);
    const nodes = [], edges = [];
    const mainId = data.paperId || data.doi || data.title;
    nodes.push({ id: mainId, label: `[ANA]\n${(data.title||'').substring(0,40)}...`, title: `${data.title}\n(${data.year||'?'})\nAtÄ±f:${data.citationCount||0}`, color:'#f0a30a', size: sizeFromCitations(data.citationCount||0), url: data.url || (data.doi?`https://doi.org/${data.doi}`:null) });

    const addList = (list, color, dir) => {
      (list||[]).forEach(item => {
        if(item.year && yearLimit && item.year < yearLimit) return;
        const id = item.paperId || item.doi || (item.title + '::' + Math.random().toString(36).slice(2,6));
        nodes.push({ id, label:(item.title||'BaÅŸlÄ±k').substring(0,40), title: `${item.title||''}\nYÄ±l:${item.year||'?'}`, color, size: sizeFromCitations(item.citationCount||0), url: item.doi?`https://doi.org/${item.doi}`: (item.url||null) });
        edges.push(dir==='ref' ? { from: mainId, to: id, color:{ color } } : { from: id, to: mainId, color:{ color } });
      });
    };

    addList(data.references || [], '#4285F4', 'ref');
    addList(data.citations || [], '#34A853', 'cit');

    // dedupe
    const uniq = {};
    nodes.forEach(n => uniq[n.id] = n);
    const finalNodes = Object.values(uniq);

    graphData = { nodes: new vis.DataSet(finalNodes), edges: new vis.DataSet(edges) };
    if(network) network.destroy();
    network = new vis.Network(container, graphData, visOptions);

    // stop physics after stabilization
    network.on('stabilizationIterationsDone', () => { try{ network.physics.stop(); }catch(e){} });

    // click behaviour: single click shows info pane, double opens
    network.on('click', params => {
      if(params.nodes.length){
        const node = graphData.nodes.get(params.nodes[0]);
        infoBox.style.display = 'block';
        infoBox.innerHTML = `<b>${node.label}</b><br>${node.title || ''}<br>${node.url ? `<a href="${node.url}" target="_blank">Makale sayfasÄ±</a>` : ''}`;
      } else {
        infoBox.style.display = 'none';
      }
    });
    network.on('doubleClick', params => {
      if(params.nodes.length){
        const node = graphData.nodes.get(params.nodes[0]);
        if(node && node.url) window.open(node.url, '_blank');
      }
    });

    // center button
    centerButton.onclick = () => { if(network) network.fit({ animation: { duration: 600 } }); };

    // subtle flourish
    container.animate([{ boxShadow: '0 0 0px var(--shadow)' }, { boxShadow: '0 0 25px var(--shadow)' }], { duration: 800, iterations: 2 });
  }

  // expose for debug
  window.searchPaper = searchPaper;
});
</script>
</body>
</html>
