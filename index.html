<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>By Selim - AtÄ±f Zinciri GÃ¶rselleÅŸtirici</title>

  <!-- vis.js -->
  <script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css">

  <!-- html2canvas + jspdf for export (PNG/PDF) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    :root{
      --bg: linear-gradient(135deg,#f7f9ff,#e9eeff);
      --accent:#2b4eff; --shadow: rgba(43,78,255,0.15);
      --card:#fff; --text:#111;
    }
    body.dark{ --bg: linear-gradient(135deg,#0f1116,#1a1d23); --accent:#00bfff; --card:#1f1f1f; --text:#eee; --shadow: rgba(0,191,255,0.18); }
    body{ margin:0; font-family:"Segoe UI",sans-serif; background:var(--bg); color:var(--text); transition:0.35s; text-align:center; }
    h1{ margin:18px 0; color:var(--accent); text-shadow:1px 1px 3px rgba(0,0,0,0.15);}
    #controls{ display:flex; flex-wrap:wrap; gap:10px; justify-content:center; margin:12px; align-items:center; }
    input,select,button{ padding:10px 12px; border-radius:8px; border:1px solid #ccc; font-size:14px; }
    button{ background:var(--accent); color:#fff; border:none; cursor:pointer; box-shadow:0 3px 6px var(--shadow); }
    #network{ width:90%; height:560px; margin:12px auto; border-radius:14px; background:var(--card); box-shadow:0 0 25px var(--shadow); position:relative; }
    #status{ margin:8px; font-weight:600;}
    #notes{ background: rgba(43,78,255,0.07); max-width:760px; margin:8px auto; padding:12px; border-radius:10px; font-size:14px; text-align:left; }
    footer{ margin:18px 0; font-size:13px; color:gray; }
    footer a{ color:var(--accent); text-decoration:none; }
    #centerButton{ position:absolute; right:12px; top:12px; z-index:8; padding:6px 10px; border-radius:8px; border:none; background:var(--accent); color:#fff; cursor:pointer;}
    #history{ padding:8px 10px; border-radius:8px; }
    .side-controls{ display:flex; gap:8px; align-items:center; }
    /* small responsive */
    @media (max-width:720px){ #network{ height:450px; } input{ width:200px; } }
  </style>
</head>
<body>
  <h1>By Selim - AtÄ±f Zinciri GÃ¶rselleÅŸtirici</h1>

  <div id="controls">
    <input id="paperInput" placeholder="DOI girin (Ã¶rn: 10.1109/5.771073)" style="width:340px">
    <button id="searchButton">Ara</button>
    <button id="sampleButton">ğŸ² Ã–rnek DOI</button>

    <select id="yearFilter"><option value="all">TÃ¼m YÄ±llar</option><option value="2010">2010+</option><option value="2015">2015+</option><option value="2020">2020+</option></select>

    <div class="side-controls">
      <button id="savePNG">ğŸ’¾ PNG</button>
      <button id="savePDF">ğŸ“„ PDF</button>
      <button id="themeBtn">ğŸŒ™</button>
      <button id="favoriteBtn" title="Favorilere ekle">â­</button>
      <select id="history" title="Arama geÃ§miÅŸi"></select>
    </div>
  </div>

  <div id="status">HazÄ±r â€” DOI girip Ara'ya basÄ±n.</div>
  <div id="network"><button id="centerButton">ğŸ¯ Ortala</button></div>

  <!-- Daha ayrÄ±ntÄ±lÄ± aÃ§Ä±klama (senin istediÄŸin eski biÃ§ime dÃ¶nÃ¼yor) -->
  <div id="notes">
    <strong>KÄ±sa kullanÄ±m rehberi</strong><br>
    â€¢ DOI'yi kutuya yapÄ±ÅŸtÄ±rÄ±n (Ã¶r. <code>10.1109/5.771073</code>) ve <b>Ara</b> butonuna tÄ±klayÄ±n.<br>
    â€¢ Uygulama Ã¶nce Semantic Scholar'dan veri Ã§eker (daha kaliteli atÄ±f/referans verisi).<br>
    â€¢ EÄŸer Semantic Scholar eksik veri verirse, OpenAlex'e dÃ¼ÅŸÃ¼lÃ¼r â€” OpenAlex genelde daha fazla atÄ±f/kaynak gÃ¶sterir. (Bu yÃ¼zden bazÄ± DOI'lerde Ã¶nce az Ã§Ä±kÄ±p sonra OpenAlex ile tam dolu gÃ¶rÃ¼nÃ¼r.)<br>
    â€¢ Yine veri eksikse Crossref'den en az baÅŸlÄ±k/yÄ±l bilgisi alÄ±nÄ±r.<br>
    â€¢ Ortadaki turuncu dÃ¼ÄŸÃ¼m kÃ¶k makaledir. Sol taraf (mavi) kaynakÃ§a / referanslar, saÄŸ taraf (yeÅŸil) makaleye atÄ±f yapan yeni makalelerdir.<br>
    â€¢ DÃ¼ÄŸÃ¼me tÄ±klayÄ±nca ilgili makalenin DOI veya OpenAlex/SemanticScholar sayfasÄ± yeni sekmede aÃ§Ä±lÄ±r.<br>
    â€¢ <b>Not:</b> Ã‡ok bÃ¼yÃ¼k makalelerde (binlerce atÄ±f) performans iÃ§in gÃ¶sterim sÄ±nÄ±rÄ± vardÄ±r; ayarlar iÃ§inde Ã¶rnek 60â€“200 arasÄ± sÄ±nÄ±r uygulanÄ±r.<br>
    â€¢ <em>Geri bildirimi / hata raporlarÄ±nÄ± <a href="mailto:omurselim@gmail.com">omurselim@gmail.com</a> adresine gÃ¶nderebilirsiniz.</em>
  </div>

  <footer>Â© 2025 <b>Selim Ã–MÃœR</b> â€” <a href="mailto:omurselim@gmail.com">omurselim@gmail.com</a> â€” Ä°zinsiz kullanÄ±lamaz.</footer>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // DOM elemanlarÄ±
  const paperInput = document.getElementById('paperInput');
  const searchButton = document.getElementById('searchButton');
  const sampleButton = document.getElementById('sampleButton');
  const yearFilter = document.getElementById('yearFilter');
  const status = document.getElementById('status');
  const container = document.getElementById('network');
  const centerButton = document.getElementById('centerButton');
  const themeBtn = document.getElementById('themeBtn');
  const savePNG = document.getElementById('savePNG');
  const savePDF = document.getElementById('savePDF');
  const favoriteBtn = document.getElementById('favoriteBtn');
  const historySelect = document.getElementById('history');

  // Proxy for Semantic Scholar to avoid CORS
  const proxy = 'https://api.allorigins.win/raw?url=';

  let network = null;
  let graphData = null;
  let lastDOI = null;

  const options = { nodes:{shape:'dot',font:{size:14}}, edges:{width:2, arrows:{to:{enabled:true}}}, physics:{stabilization:true} };

  // History & favorites (localStorage)
  function addToHistory(doi){
    if(!doi) return;
    let h = JSON.parse(localStorage.getItem('sa_history')||'[]');
    h = h.filter(x=>x!==doi);
    h.unshift(doi);
    if(h.length>20) h.pop();
    localStorage.setItem('sa_history', JSON.stringify(h));
    renderHistory();
  }
  function renderHistory(){
    const h = JSON.parse(localStorage.getItem('sa_history')||'[]');
    historySelect.innerHTML = '<option value="">GeÃ§miÅŸ</option>' + h.map(d=>`<option value="${d}">${d}</option>`).join('');
  }
  function toggleFavorite(doi){
    if(!doi) return;
    let f = JSON.parse(localStorage.getItem('sa_fav')||'[]');
    if(f.includes(doi)){ f = f.filter(x=>x!==doi); favoriteBtn.style.opacity=0.6; }
    else { f.unshift(doi); favoriteBtn.style.opacity=1; }
    localStorage.setItem('sa_fav', JSON.stringify(f));
  }
  function updateFavoriteBtn(doi){
    const f = JSON.parse(localStorage.getItem('sa_fav')||'[]');
    favoriteBtn.style.opacity = f.includes(doi)?1:0.6;
  }

  renderHistory();
  historySelect.addEventListener('change', ()=>{ if(historySelect.value) { paperInput.value = historySelect.value; searchPaper(); }});

  // UI events
  sampleButton.onclick = ()=> {
    const samples = ["10.1109/5.771073","10.1038/nature12373","10.48550/arXiv.1706.03762","10.1145/3368089.3409694"];
    paperInput.value = samples[Math.floor(Math.random()*samples.length)];
    searchPaper();
  };
  themeBtn.onclick = ()=> { document.body.classList.toggle('dark'); themeBtn.textContent = document.body.classList.contains('dark') ? 'â˜€ï¸' : 'ğŸŒ™'; };

  centerButton.onclick = ()=> { if(network) network.fit({animation:{duration:600}}); };

  savePNG.onclick = async () => {
    if(!network) return alert('Ã–nce bir grafik oluÅŸturun!');
    const canvas = network.canvas.frame.canvas;
    const dataUrl = canvas.toDataURL('image/png');
    const a = document.createElement('a'); a.href = dataUrl; a.download = 'atif-grafik.png'; a.click();
  };

  savePDF.onclick = async () => {
    if(!network) return alert('Ã–nce bir grafik oluÅŸturun!');
    const canvas = network.canvas.frame.canvas;
    const imgData = canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation:'landscape' });
    const w = pdf.internal.pageSize.getWidth();
    const h = pdf.internal.pageSize.getHeight();
    pdf.addImage(imgData, 'PNG', 10, 10, w-20, h-20);
    pdf.save('atif-grafik.pdf');
  };

  favoriteBtn.onclick = ()=> { toggleFavorite(lastDOI); };

  paperInput.addEventListener('keyup', e => { if(e.key==='Enter') searchPaper(); });
  searchButton.onclick = searchPaper;

  /* ---------------------------
     Veri Ã§ekme mantÄ±ÄŸÄ± (Ã¶ncelik sÄ±rasÄ±)
     1) Semantic Scholar (proxy ile CORS atlatma)
     2) EÄŸer SS'de references/citations azsa -> OpenAlex'ten ek Ã§ek (referanslar + citing works)
     3) EÄŸer hÃ¢lÃ¢ veri yoksa Crossref fallback
     ---------------------------*/

  async function searchPaper(){
    const doi = paperInput.value.trim();
    if(!doi){ status.textContent = 'âš ï¸ LÃ¼tfen DOI girin.'; return; }
    lastDOI = doi; updateFavoriteBtn(doi);
    status.textContent = 'ğŸ” Veri Ã§ekiliyor... (Semantic Scholar â†’ OpenAlex â†’ Crossref)';
    container.classList.add('loading');

    try {
      // 1) Semantic Scholar via proxy
      const ssUrl = `https://api.semanticscholar.org/graph/v1/paper/DOI:${encodeURIComponent(doi)}?fields=title,year,authors,doi,paperId,url,citationCount,references.paperId,references.title,references.year,references.doi,citations.paperId,citations.title,citations.year,citations.doi`;
      let ssResp = await fetch(proxy + encodeURIComponent(ssUrl));
      let ssJson = ssResp.ok ? await ssResp.json().catch(()=>null) : null;

      let data = null;
      const ssHasRefs = ssJson && Array.isArray(ssJson.references) && ssJson.references.length>0;
      const ssHasCits = ssJson && Array.isArray(ssJson.citations) && ssJson.citations.length>0;

      // If SS has reasonably many refs/cits, use it directly
      if(ssJson && (ssHasRefs || ssHasCits)) {
        data = ssJson;
      } else {
        // try OpenAlex for more complete coverage (esp. citation lists)
        try {
          const openalexUrl = `https://api.openalex.org/works/https://doi.org/${encodeURIComponent(doi)}`;
          const oxResp = await fetch(openalexUrl);
          if(oxResp.ok){
            const ox = await oxResp.json();
            // basic data
            data = {
              title: ox.title,
              year: ox.publication_year,
              doi: doi,
              paperId: ox.id,
              url: ox.id ? `https://openalex.org/${ox.id.split('/').pop()}` : (ox.open_access?.oa_url || null),
              citationCount: ox.cited_by_count || 0,
              references: [],
              citations: []
            };

            // references: ox.referenced_works contains OpenAlex ids. Fetch details (limit 120)
            const refs = (ox.referenced_works || []).slice(0,120);
            const refFetches = refs.map(id => fetch(id).then(r=>r.ok?r.json():null).catch(()=>null));
            const refsData = await Promise.all(refFetches);
            refsData.forEach(r => {
              if(!r) return;
              data.references.push({
                title: r.title,
                paperId: r.id,
                doi: r.doi || null,
                year: r.publication_year,
                citationCount: r.cited_by_count || 0,
                url: r.primary_location?.source_url || `https://openalex.org/${r.id.split('/').pop()}`
              });
            });

            // citations: get works that cite this OpenAlex ID (per_page up to 200)
            if(ox.id){
              const citesResp = await fetch(`https://api.openalex.org/works?filter=cites:${encodeURIComponent(ox.id)}&per_page=200`);
              if(citesResp.ok){
                const citesJson = await citesResp.json();
                (citesJson.results || []).forEach(r => {
                  data.citations.push({
                    title: r.title,
                    paperId: r.id,
                    doi: r.doi || null,
                    year: r.publication_year,
                    citationCount: r.cited_by_count || 0,
                    url: r.primary_location?.source_url || `https://openalex.org/${r.id.split('/').pop()}`
                  });
                });
              }
            }
          }
        } catch(e){
          console.warn('OpenAlex hata', e);
        }
      }

      // If data still empty, but ssJson exists (even if limited), use ssJson as base
      if(!data && ssJson){
        data = ssJson;
      }

      // If still no data, fallback to Crossref minimal record
      if(!data){
        try{
          const crResp = await fetch(`https://api.crossref.org/works/${encodeURIComponent(doi)}`);
          if(crResp.ok){
            const cr = await crResp.json();
            const msg = cr.message;
            data = { title: msg.title?.[0]||'BaÅŸlÄ±k yok', year: msg.created?.['date-parts']?.[0]?.[0]||null, doi: msg.DOI, references: [], citations: [], url: msg.URL || `https://doi.org/${msg.DOI}` };
          }
        } catch(e) { /* ignore */ }
      }

      if(!data){ status.textContent = 'âŒ Veriler alÄ±namadÄ± (Semantic Scholar / OpenAlex / Crossref).'; return; }

      // store history & update UI
      addToHistory(doi);
      lastDOI = doi; updateFavoriteBtn(doi);

      // draw merged/complete data
      fullDraw(data);
      status.textContent = `âœ… "${data.title||doi}" gÃ¶rselleÅŸtirildi.`;
    } catch(err){
      console.error(err);
      status.textContent = 'âŒ Beklenmedik hata. Konsolu kontrol edin.';
    } finally {
      container.classList.remove('loading');
    }
  } // end searchPaper

  // Deterministic node size based on citation count
  // citationCount >=0 -> size = 12 + clamp(round(log10(1+count)*22), 0..40)
  function sizeFromCitations(count){
    const c = Math.max(0, Number(count) || 0);
    const size = 12 + Math.min(40, Math.round(Math.log10(1 + c) * 22));
    return size;
  }

  function fullDraw(data){
    const yearLimit = yearFilter.value === 'all' ? 0 : parseInt(yearFilter.value);
    const nodes = [], edges = [];

    const mainId = data.paperId || data.doi || data.title;
    const mainSize = sizeFromCitations(data.citationCount || 0);

    nodes.push({
      id: mainId,
      label:`[ANA]\n${(data.title||'BaÅŸlÄ±k').substring(0,40)}...`,
      title: `${data.title || ''}\n(${data.year || '?'})`,
      color:'#f0a30a',
      size: mainSize,
      url: data.url || (data.doi?`https://doi.org/${data.doi}`:null)
    });

    const addList = (list, color, dir) => {
      (list||[]).slice(0,200).forEach(item=>{
        if(item.year && yearLimit && item.year < yearLimit) return;
        const id = item.paperId || item.doi || item.title;
        if(!id) return;
        const s = sizeFromCitations(item.citationCount || 0);
        nodes.push({
          id,
          label:(item.title||'BaÅŸlÄ±k').substring(0,40),
          title:`${item.title || ''}\nYÄ±l:${item.year || '?'}`,
          color,
          size: s,
          url: item.doi ? `https://doi.org/${item.doi}` : (item.url || (item.paperId?`https://openalex.org/${item.paperId.split('/').pop()}`:null))
        });
        edges.push(dir==='ref' ? { from: mainId, to: id } : { from: id, to: mainId });
      });
    };

    addList(data.references || [], '#4285F4', 'ref');
    addList(data.citations || [], '#34A853', 'cit');

    // Deduplicate nodes by id
    const uniq = {};
    nodes.forEach(n=>{ uniq[n.id] = n; });
    const finalNodes = Object.values(uniq);

    graphData = { nodes: new vis.DataSet(finalNodes), edges: new vis.DataSet(edges) };
    if(network) network.destroy();
    network = new vis.Network(container, graphData, options);

    // click -> open url
    network.on('click', params=>{
      if(params.nodes.length){
        const n = graphData.nodes.get(params.nodes[0]);
        if(n && n.url) window.open(n.url, '_blank');
      }
    });

    // small flourish
    container.animate([{boxShadow:'0 0 0px var(--shadow)'},{boxShadow:'0 0 25px var(--shadow)'}],{duration:700,iterations:2});
  }

}); // end DOMContentLoaded
</script>
</body>
</html>
