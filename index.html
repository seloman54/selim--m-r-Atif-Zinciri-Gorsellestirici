<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>By Selim - AtÄ±f Zinciri GÃ¶rselleÅŸtirici</title>

<!-- vis.js -->
<script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css">

<!-- html2canvas + jspdf for export -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
:root{
  --bg: linear-gradient(135deg,#f7f9ff,#e9eeff);
  --accent:#2b4eff; --shadow: rgba(43,78,255,0.15);
  --card:#fff; --text:#111;
}
body.dark{ --bg: linear-gradient(135deg,#0f1116,#1a1d23); --accent:#00bfff; --card:#1f1f1f; --text:#eee; --shadow: rgba(0,191,255,0.18); }
body{ margin:0; font-family:"Segoe UI",sans-serif; background:var(--bg); color:var(--text); transition:0.35s; text-align:center; }
h1{ margin:18px 0; color:var(--accent); text-shadow:1px 1px 3px rgba(0,0,0,0.15);}
#controls{ display:flex; flex-wrap:wrap; gap:10px; justify-content:center; margin:12px; align-items:center; }
input,select,button{ padding:10px 12px; border-radius:8px; border:1px solid #ccc; font-size:14px; }
button{ background:var(--accent); color:#fff; border:none; cursor:pointer; box-shadow:0 3px 6px var(--shadow); }
#network{ width:90%; height:620px; margin:12px auto; border-radius:14px; background:var(--card); box-shadow:0 0 25px var(--shadow); position:relative; }
#status{ margin:8px; font-weight:600; min-height:20px; }
#notes{ background: rgba(43,78,255,0.07); max-width:760px; margin:8px auto; padding:12px; border-radius:10px; font-size:14px; text-align:left; line-height:1.5; }
footer{ margin:18px 0; font-size:13px; color:gray; }
footer a{ color:var(--accent); text-decoration:none; }
#centerButton{ position:absolute; right:12px; top:12px; z-index:8; padding:6px 10px; border-radius:8px; border:none; background:var(--accent); color:#fff; cursor:pointer;}
#spinner{ display:none; border:4px solid #f3f3f3; border-top:4px solid var(--accent); border-radius:50%; width:30px; height:30px; margin:6px auto; animation:spin 1s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }
.legend { display:flex; gap:10px; justify-content:center; margin-top:8px; font-size:13px; color: #333; }
.legend .item { display:flex; gap:6px; align-items:center; }
.legend .sw { width:14px; height:12px; border-radius:3px; display:inline-block }
@media (max-width:720px){ #network{ height:520px; } input{ width:200px; } }
.infoBox {
  position: absolute;
  left: 12px;
  top: 12px;
  z-index: 10;
  background: rgba(255,255,255,0.95);
  padding: 8px 10px;
  border-radius: 8px;
  box-shadow: 0 4px 14px rgba(0,0,0,0.08);
  font-size: 13px;
}
.infoBox.dark { background: rgba(30,30,30,0.9); color: #eee; }
</style>
</head>
<body>
<h1>By Selim - AtÄ±f Zinciri GÃ¶rselleÅŸtirici</h1>

<div id="controls">
  <input id="paperInput" placeholder="DOI girin (Ã¶r: 10.1109/5.771073)" style="width:360px">
  <button id="searchButton">Ara</button>
  <button id="sampleButton">ğŸ² Ã–rnek DOI</button>

  <select id="yearFilter">
    <option value="all">TÃ¼m YÄ±llar</option>
    <option value="2010">2010+</option>
    <option value="2015">2015+</option>
    <option value="2020">2020+</option>
  </select>

  <button id="savePNG">ğŸ’¾ PNG</button>
  <button id="savePDF">ğŸ“„ PDF</button>
  <button id="centerBtn">ğŸ§­ Ortala</button>
  <button id="toggleEdges">ğŸ”—</button>
  <button id="focusToggle">ğŸ¯ Odak</button>
  <button id="themeBtn">ğŸŒ™</button>
  <button id="favBtn" title="Favori">â­</button>
  <select id="history" style="min-width:140px"></select>
</div>

<div id="spinner"></div>
<div id="status">HazÄ±r â€” DOI girip Ara'ya basÄ±n.</div>

<div id="network">
  <div id="infoBox" class="infoBox" style="display:none"></div>
</div>

<div class="legend">
  <div class="item"><span class="sw" style="background:#f0a30a"></span> Ana makale</div>
  <div class="item"><span class="sw" style="background:#4285F4"></span> KaynakÃ§a (references)</div>
  <div class="item"><span class="sw" style="background:#34A853"></span> AtÄ±flar (citations)</div>
</div>

<div id="notes">
<strong>KÄ±sa kullanÄ±m rehberi</strong><br>
â€¢ DOI'yi yapÄ±ÅŸtÄ±rÄ±n ve <b>Ara</b> ya tÄ±klayÄ±n.<br>
â€¢ Uygulama Ã¶ncelikle Semantic Scholar Graph API kullanÄ±r; tarayÄ±cÄ±-CORS engelini atlamak iÃ§in birden fazla proxy denemesi yapÄ±lÄ±r. (EÄŸer proxylerden biri cevap verirse veri gelecektir.)<br>
â€¢ AtÄ±f/kaynak verileri sayfalar hÃ¢linde Ã§ekilir; bÃ¼yÃ¼k makaleler iÃ§in birkaÃ§ saniye sÃ¼rebilir.<br>
â€¢ DÃ¼ÄŸÃ¼mler kesin formÃ¼lle boyutlanÄ±r: <code>size = 5 + Math.sqrt(citationCount) * 4</code>.<br>
â€¢ <b>ğŸ”—</b> ile kenarlarÄ± gizleyebilir; <b>ğŸ¯ Odak</b> aÃ§Ä±kken tÄ±klanan dÃ¼ÄŸÃ¼m merkeze gelir; <b>Ortala</b> her zaman grafiÄŸi sÄ±ÄŸdÄ±rÄ±r.<br>
â€¢ Hatalar: eÄŸer hÃ¢lÃ¢ "Failed to fetch" alÄ±rsanÄ±z konsolu (F12 â†’ Console) kopyalayÄ±p gÃ¶nderin; alternatif proxy kurulumu Ã¶neririm.<br>
</div>

<footer>Â© 2025 <b>Selim Ã–MÃœR</b> â€” <a href="mailto:omurselim@gmail.com">omurselim@gmail.com</a> â€” Ä°zinsiz kullanÄ±lamaz.</footer>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // DOM
  const paperInput = document.getElementById('paperInput');
  const searchButton = document.getElementById('searchButton');
  const sampleButton = document.getElementById('sampleButton');
  const yearFilter = document.getElementById('yearFilter');
  const spinner = document.getElementById('spinner');
  const status = document.getElementById('status');
  const container = document.getElementById('network');
  const infoBox = document.getElementById('infoBox');
  const savePNG = document.getElementById('savePNG');
  const savePDF = document.getElementById('savePDF');
  const centerBtn = document.getElementById('centerBtn');
  const toggleEdges = document.getElementById('toggleEdges');
  const focusToggle = document.getElementById('focusToggle');
  const themeBtn = document.getElementById('themeBtn');
  const favBtn = document.getElementById('favBtn');
  const historySelect = document.getElementById('history');

  const proxies = [
    '', // try direct first
    'https://api.allorigins.win/raw?url=',
    'https://corsproxy.io/?',
    'https://cors.isomorphic-git.org/'
  ];

  let network = null;
  let graphData = null;
  let lastDOI = null;
  let edgesShown = true;
  let focusMode = false;

  // options tuned to reduce overlap and improve readability
  const options = {
    nodes: { shape: 'dot', font: { size: 14 }, borderWidth: 1.5 },
    edges: {
      width: 1.6,
      smooth: { type: 'dynamic' , forceDirection: 'none', roundness: 0.35 },
      arrows: { to: { enabled: true, scaleFactor: 0.6 } },
      color: { inherit: false }
    },
    physics: {
      stabilization: true,
      barnesHut: { gravitationalConstant: -25000, springLength: 140, springConstant: 0.02 }
    },
    interaction: { hover: true, tooltipDelay: 100 }
  };

  // history/fav
  function addToHistory(doi){
    if(!doi) return;
    let h = JSON.parse(localStorage.getItem('sa_history')||'[]');
    h = h.filter(x=>x!==doi);
    h.unshift(doi);
    if(h.length>30) h.pop();
    localStorage.setItem('sa_history', JSON.stringify(h));
    renderHistory();
  }
  function renderHistory(){
    const h = JSON.parse(localStorage.getItem('sa_history')||'[]');
    historySelect.innerHTML = '<option value="">GeÃ§miÅŸ</option>' + h.map(d=>`<option value="${d}">${d}</option>`).join('');
  }
  function toggleFav(doi){
    if(!doi) return;
    let f = JSON.parse(localStorage.getItem('sa_fav')||'[]');
    if(f.includes(doi)){ f = f.filter(x=>x!==doi); favBtn.style.opacity=0.6; }
    else { f.unshift(doi); favBtn.style.opacity=1; }
    localStorage.setItem('sa_fav', JSON.stringify(f));
  }
  function updateFav(doi){
    const f = JSON.parse(localStorage.getItem('sa_fav')||'[]');
    favBtn.style.opacity = f.includes(doi)?1:0.6;
  }
  renderHistory();

  // events
  sampleButton.onclick = () => {
    const samples = ["10.1109/5.771073","10.1038/nrn3241","10.1038/nature12373","10.48550/arXiv.1706.03762"];
    paperInput.value = samples[Math.floor(Math.random()*samples.length)];
    searchPaper();
  };
  searchButton.onclick = searchPaper;
  historySelect.onchange = ()=> { if(historySelect.value){ paperInput.value = historySelect.value; searchPaper(); } };
  themeBtn.onclick = ()=> { document.body.classList.toggle('dark'); infoBox.classList.toggle('dark'); themeBtn.textContent = document.body.classList.contains('dark') ? 'â˜€ï¸' : 'ğŸŒ™'; };
  savePNG.onclick = () => exportPNG();
  savePDF.onclick = () => exportPDF();
  centerBtn.onclick = ()=> { if(network) network.fit({ animation:{ duration: 600 } }); };
  toggleEdges.onclick = ()=> {
    edgesShown = !edgesShown;
    if(graphData) graphData.edges.getIds().forEach(id=> graphData.edges.update({ id, hidden: !edgesShown }));
    toggleEdges.textContent = edgesShown ? 'ğŸ”—' : 'âœ‚ï¸';
  };
  focusToggle.onclick = ()=> { focusMode = !focusMode; focusToggle.style.opacity = focusMode?1:0.8; };
  favBtn.onclick = ()=> { toggleFav(lastDOI); };

  paperInput.addEventListener('keyup', e => { if(e.key==='Enter') searchPaper(); });

  // small timeout helper for fetch
  function fetchWithTimeout(resource, options = {}) {
    const { timeout = 10000 } = options;
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    return fetch(resource, { ...options, signal: controller.signal })
      .finally(() => clearTimeout(id));
  }

  // robust fetch trying proxies in order
  async function robustFetch(url, opts = {}) {
    let lastErr = null;
    for(const p of proxies){
      try{
        const attemptUrl = p ? (p + encodeURIComponent(url)) : url;
        const res = await fetchWithTimeout(attemptUrl, { timeout: 10000 });
        if(!res.ok) { lastErr = new Error('HTTP ' + res.status + ' from ' + attemptUrl); continue; }
        const contentType = res.headers.get('content-type') || '';
        if(contentType.includes('application/json') || contentType.includes('text/json') || contentType.includes('application/octet-stream') || contentType.includes('text/plain')) {
          const json = await res.json().catch(()=>null);
          if(json) return json;
        } else {
          // some proxies return raw text JSON
          const text = await res.text();
          try { return JSON.parse(text); } catch(e){ return text; }
        }
      } catch(e){
        lastErr = e;
        // try next proxy
      }
    }
    // all failed
    throw lastErr || new Error('All proxies failed');
  }

  // pagination fetch for S2 graph endpoints (limit, offset)
  async function fetchAllPagesSS(endpointBase, itemKeyName){
    const all = [];
    const pageSize = 100;
    let offset = 0;
    while(true){
      const pageUrl = endpointBase + `&limit=${pageSize}&offset=${offset}`;
      const j = await robustFetch(pageUrl).catch(e => { throw e; });
      // attempt to extract items
      const items = j.data || j.results || j.citations || j.references || [];
      if(!Array.isArray(items) || items.length === 0) break;
      // normalize
      items.forEach(it => {
        // items may be { citingPaper: {...} } or { reference: {...} }
        const unified = it.citingPaper || it.reference || it;
        if(unified) all.push(unified);
      });
      if(items.length < pageSize) break;
      offset += pageSize;
      // gentle pause
      await new Promise(r => setTimeout(r, 150));
      // safety cap
      if(offset > 5000) break;
    }
    return all;
  }

  // deterministic size
  function sizeFromCitations(count){
    const c = Math.max(0, Number(count) || 0);
    return Math.round(5 + Math.sqrt(c) * 4);
  }

  // main search
  async function searchPaper(){
    const doi = paperInput.value.trim();
    if(!doi){ status.textContent = 'âš ï¸ LÃ¼tfen DOI girin.'; return; }
    lastDOI = doi;
    updateFav(doi);
    spinner.style.display = 'block';
    status.textContent = 'ğŸ” Veri Ã§ekiliyor... (Semantic Scholar, pagination ile). LÃ¼tfen bekleyin...';

    try{
      // 1 - main paper to get paperId
      const mainUrl = `https://api.semanticscholar.org/graph/v1/paper/DOI:${encodeURIComponent(doi)}?fields=title,year,authors,doi,paperId,url,citationCount`;
      const main = await robustFetch(mainUrl);
      if(!main || !main.paperId){
        throw new Error('Semantic Scholar ana makale bulunamadÄ±.');
      }

      // 2 - fetch references and citations via pagination endpoints
      const refsBase = `https://api.semanticscholar.org/graph/v1/paper/${encodeURIComponent(main.paperId)}/references?fields=reference.paperId,reference.title,reference.year,reference.doi,reference.citationCount`;
      const citsBase = `https://api.semanticscholar.org/graph/v1/paper/${encodeURIComponent(main.paperId)}/citations?fields=citingPaper.paperId,citingPaper.title,citingPaper.year,citingPaper.doi,citingPaper.citationCount`;

      // Attempt to fetch both concurrently but handle failures individually
      const [refs, cits] = await Promise.all([
        fetchAllPagesSS(refsBase, 'references').catch(e => { console.warn('refs failed', e); return []; }),
        fetchAllPagesSS(citsBase, 'citations').catch(e => { console.warn('cits failed', e); return []; })
      ]);

      // if both empty (rare), fallback to OpenAlex for expanded coverage
      let data = {
        title: main.title,
        year: main.year,
        doi: main.doi,
        paperId: main.paperId,
        url: main.url || (main.doi ? `https://doi.org/${main.doi}` : null),
        citationCount: main.citationCount || 0,
        references: refs.map(r => ({
          title: r.title || r.reference?.title || 'BaÅŸlÄ±k yok',
          paperId: r.paperId || r.reference?.paperId || r.reference?.doi || null,
          doi: r.doi || r.reference?.doi || null,
          year: r.year || r.reference?.year || null,
          citationCount: r.citationCount || r.reference?.citationCount || 0,
          url: r.url || null
        })),
        citations: cits.map(c => {
          const p = c.citingPaper || c;
          return {
            title: p.title || 'BaÅŸlÄ±k yok',
            paperId: p.paperId || p.doi || null,
            doi: p.doi || null,
            year: p.year || null,
            citationCount: p.citationCount || 0,
            url: p.url || null
          };
        })
      };

      // If both lists are suspiciously empty (0) then try OpenAlex as fallback for coverage
      if(data.references.length === 0 && data.citations.length === 0){
        try{
          const openalexUrl = `https://api.openalex.org/works/https://doi.org/${encodeURIComponent(doi)}`;
          const ox = await robustFetch(openalexUrl).catch(()=>null);
          if(ox && ox.id){
            // build data from OpenAlex
            data = {
              title: ox.title || data.title,
              year: ox.publication_year || data.year,
              doi: doi,
              paperId: ox.id,
              url: ox.open_access?.oa_url || `https://openalex.org/${ox.id.split('/').pop()}`,
              citationCount: ox.cited_by_count || data.citationCount || 0,
              references: [],
              citations: []
            };
            // referenced works (limited)
            const refsOX = (ox.referenced_works || []).slice(0,200);
            const refFetches = refsOX.map(id => robustFetch(id).catch(()=>null));
            const refsData = await Promise.all(refFetches);
            refsData.forEach(r=>{
              if(!r) return;
              data.references.push({
                title: r.title, paperId: r.id, doi: r.doi || null, year: r.publication_year, citationCount: r.cited_by_count || 0, url: r.primary_location?.source_url || null
              });
            });
            // citing works
            const citesResp = await robustFetch(`https://api.openalex.org/works?filter=cites:${encodeURIComponent(ox.id)}&per_page=200`).catch(()=>null);
            if(citesResp && Array.isArray(citesResp.results)){
              citesResp.results.forEach(r => data.citations.push({
                title: r.title, paperId: r.id, doi: r.doi || null, year: r.publication_year, citationCount: r.cited_by_count || 0, url: r.primary_location?.source_url || null
              }));
            }
          }
        } catch(e){ console.warn('OpenAlex fallback failed', e); }
      }

      // store history & update fav
      addToHistory(doi);
      lastDOI = doi;
      updateFav(doi);

      // draw
      drawGraph(data);
      status.textContent = `âœ… "${data.title}" gÃ¶sterildi. (refs: ${data.references.length}, cits: ${data.citations.length})`;
    } catch(err){
      console.error('search error', err);
      status.textContent = `âŒ Veri alÄ±namadÄ±: ${err.message || err}. (Konsolu kontrol et.)`;
    } finally {
      spinner.style.display = 'none';
    }
  } // end searchPaper

  // draw graph preserving old look, with deterministic sizes
  function drawGraph(data){
    fullData = data;
    const yearLimit = yearFilter.value === 'all' ? 0 : parseInt(yearFilter.value);
    const nodes = [], edges = [];

    const mainId = data.paperId || data.doi || data.title;
    const mainSize = sizeFromCitations(data.citationCount || 0);

    nodes.push({
      id: mainId,
      label: `[ANA]\n${(data.title||'BaÅŸlÄ±k').substring(0,40)}...`,
      title: `${data.title || ''}\nYÄ±l:${data.year||'?' }\nAtÄ±f:${data.citationCount||0}`,
      color: '#f0a30a',
      size: mainSize,
      url: data.url || (data.doi ? `https://doi.org/${data.doi}` : null)
    });

    const add = (list, color, dir) => {
      (list||[]).forEach(item=>{
        if(item.year && yearLimit && item.year < yearLimit) return;
        const id = item.paperId || item.doi || (item.title + '::' + Math.random().toString(36).slice(2,6));
        const s = sizeFromCitations(item.citationCount || 0);
        nodes.push({
          id,
          label: (item.title||'BaÅŸlÄ±k').substring(0,45),
          title: `${item.title||''}\nYÄ±l:${item.year||'?'}\nAtÄ±f:${item.citationCount||0}`,
          color,
          size: s,
          url: item.doi ? `https://doi.org/${item.doi}` : (item.url || null)
        });
        const edgeColor = color === '#4285F4' ? '#4285F4' : '#34A853';
        edges.push(dir==='ref' ? { from: mainId, to: id, color: { color: edgeColor }, arrows: { to: { enabled: true } } } : { from: id, to: mainId, color: { color: edgeColor }, arrows: { to: { enabled: true } } });
      });
    };

    add(data.references || [], '#4285F4', 'ref');
    add(data.citations || [], '#34A853', 'cit');

    // dedupe nodes by id
    const unique = {};
    nodes.forEach(n=> unique[n.id] = n);
    const finalNodes = Object.values(unique);

    graphData = { nodes: new vis.DataSet(finalNodes), edges: new vis.DataSet(edges) };
    if(network) network.destroy();
    network = new vis.Network(container, graphData, options);

    // stop physics when stable
    network.on('stabilizationIterationsDone', () => {
      try{ network.physics.stop(); }catch(e){}
    });

    // click: show info box (small) and open link on doubleclick / with focus mode
    network.on('click', params => {
      if(params.nodes.length){
        const nid = params.nodes[0];
        const node = graphData.nodes.get(nid);
        // show infoBox near top-left
        infoBox.style.display = 'block';
        infoBox.innerHTML = `<strong>${node.label}</strong><br>${(node.title||'')}<br>${node.url? `<a href="${node.url}" target="_blank">Makale sayfasÄ±na git</a>` : ''}`;
        // focus mode
        if(focusMode){
          network.focus(nid, { scale: 1.2, animation: { duration: 600 } });
        }
      } else {
        infoBox.style.display = 'none';
      }
    });

    // double click opens link if available
    network.on('doubleClick', params => {
      if(params.nodes.length){
        const node = graphData.nodes.get(params.nodes[0]);
        if(node && node.url) window.open(node.url, '_blank');
      }
    });

    // initial edge hide/show
    graphData.edges.getIds().forEach(id => graphData.edges.update({ id, hidden: !edgesShown }));
  }

  // export helpers
  function exportPNG(){
    if(!network) return alert('Ã–nce grafik oluÅŸturun!');
    const canvas = network.canvas.frame.canvas;
    const dataUrl = canvas.toDataURL('image/png');
    const a = document.createElement('a'); a.href = dataUrl; a.download = 'atif-grafik.png'; a.click();
  }
  function exportPDF(){
    if(!network) return alert('Ã–nce grafik oluÅŸturun!');
    const canvas = network.canvas.frame.canvas;
    const imgData = canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation:'landscape' });
    const w = pdf.internal.pageSize.getWidth();
    const h = pdf.internal.pageSize.getHeight();
    pdf.addImage(imgData, 'PNG', 10, 10, w-20, h-20);
    pdf.save('atif-grafik.pdf');
  }

  // utility: fetch with timeout already above
  // expose for debug
  window.searchPaper = searchPaper;
});
</script>
</body>
</html>
