<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>By Selim - AtÄ±f Zinciri GÃ¶rselleÅŸtirici</title>

<!-- vis.js -->
<script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css" />

<!-- jspdf for export -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
:root{
  --bg: linear-gradient(135deg,#f7f9ff,#e9eeff);
  --accent:#2b4eff; --shadow: rgba(43,78,255,0.15);
  --card:#fff; --text:#111;
}
body.dark{ --bg: linear-gradient(135deg,#0f1116,#1a1d23); --accent:#00bfff; --card:#1f1f1f; --text:#eee; --shadow: rgba(0,191,255,0.18); }
body{ margin:0; font-family:"Segoe UI",sans-serif; background:var(--bg); color:var(--text); transition:0.35s; text-align:center; }
h1{ margin:18px 0; color:var(--accent); text-shadow:1px 1px 3px rgba(0,0,0,0.15); }
#controls{ margin:20px; display:flex; flex-wrap:wrap; gap:10px; justify-content:center; align-items:center; }
input,select,button{ padding:10px 14px; font-size:14px; border-radius:8px; border:1px solid #ccc; }
button{ background:var(--accent); color:#fff; border:none; cursor:pointer; box-shadow:0 3px 6px var(--shadow); }
#topSummary { max-width:1000px; margin:10px auto; background:var(--card); padding:12px 16px; border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,0.06); text-align:left; font-size:0.95rem; }
#networks { display:flex; gap:12px; justify-content:center; align-items:flex-start; width:95%; margin:10px auto; }
.networkCard { flex:1; min-width:300px; background:var(--card); border-radius:12px; padding:10px; box-shadow:0 10px 24px rgba(0,0,0,0.04); position:relative; overflow:hidden; }
.networkHeader { font-weight:600; color:var(--accent); margin-bottom:8px; text-align:left; }
#leftNet, #rightNet { width:100%; height:520px; border-radius:10px; background:transparent; }
#status{ margin:10px; font-weight:500; min-height:20px; }
#spinner{ display:none; border:4px solid #f3f3f3; border-top:4px solid var(--accent); border-radius:50%; width:30px; height:30px; margin:6px auto; animation:spin 1s linear infinite; }
@keyframes spin{ to{ transform:rotate(360deg); } }
#notes{ background: rgba(43,78,255,0.07); padding:12px; border-radius:10px; max-width:900px; margin:10px auto; font-size:0.9em; text-align:left; color: #0b2166; }
footer{ margin:25px 0; font-size:0.8em; color:gray; }
footer a{ color:var(--accent); text-decoration:none; }

/* small translucent hint in top-right corner of each network card */
.zoomHint {
  position: absolute;
  right: 12px;
  top: 12px;
  z-index: 40;
  background: rgba(255,255,255,0.75);
  padding: 6px 10px;
  border-radius: 8px;
  font-size: 12px;
  color: #333;
  box-shadow: 0 6px 18px rgba(0,0,0,0.06);
  pointer-events: none;
}
body.dark .zoomHint { background: rgba(20,20,20,0.65); color: #eee; }

/* left header color override (green) */
.leftHeader { color: #34A853 !important; }

/* info box */
.infoBox { position:absolute; left:12px; top:12px; z-index:60; display:none; max-width:360px; background:rgba(255,255,255,0.96); padding:10px 12px; border-radius:8px; box-shadow:0 8px 20px rgba(0,0,0,0.08); text-align:left; font-size:13px; }
body.dark .infoBox{ background:rgba(20,20,20,0.95); color:#eee; }

@media (max-width:980px){
  #networks { flex-direction:column; }
  #leftNet, #rightNet { height:420px; }
  .zoomHint { display:none; } /* hide hint on small screens */
}
</style>
</head>
<body>
  <h1>By Selim - AtÄ±f Zinciri GÃ¶rselleÅŸtirici</h1>

  <div id="controls">
    <input id="paperInput" placeholder="Makale DOI'si (Ã¶rn: 10.1109/5.771073)" style="width:420px">
    <button id="searchButton">Ara</button>
    <button id="sampleButton">ğŸ² Ã–rnek DOI</button>
    <select id="yearFilter">
      <option value="all">TÃ¼m YÄ±llar</option>
      <option value="2010">2010+</option>
      <option value="2015">2015+</option>
      <option value="2020">2020+</option>
    </select>
    <button id="savePng">ğŸ’¾ PNG</button>
    <button id="savePdf">ğŸ“„ PDF</button>
    <button id="themeBtn">ğŸŒ™ Gece Modu</button>
  </div>

  <div id="spinner"></div>
  <div id="status">HazÄ±r â€” DOI girip Ara'ya basÄ±n.</div>

  <div id="topSummary"> <!-- summary will be injected here --> KÄ±sa Ã¶zet: <i>HenÃ¼z makale yÃ¼klenmedi.</i></div>

  <div id="networks">
    <div class="networkCard">
      <div class="networkHeader leftHeader">AtÄ±flar (Ana makaleye atÄ±f yapan makaleler) â€” <span style="color:#34A853">YeÅŸil</span></div>
      <div class="zoomHint">ğŸ–±ï¸ Fare tekerleÄŸiyle yakÄ±nlaÅŸtÄ±rÄ±n Â· SÃ¼rÃ¼kleyin</div>
      <div id="leftNet"></div>
    </div>
    <div class="networkCard">
      <div class="networkHeader">KaynakÃ§alar (KÃ¶k makalenin kullandÄ±klarÄ±) â€” Mavi</div>
      <div class="zoomHint">ğŸ–±ï¸ Fare tekerleÄŸiyle yakÄ±nlaÅŸtÄ±rÄ±n Â· SÃ¼rÃ¼kleyin</div>
      <div id="rightNet"></div>
    </div>
  </div>

  <div class="infoBox" id="infoBox"></div>

  <div id="notes">
    ğŸ”¹ Sol: ana makaleye atÄ±f yapan Ã§alÄ±ÅŸmalar (citations).<br>
    ğŸ”¹ SaÄŸ: makalenin kaynakÃ§asÄ± (references). Bu panelde <strong>en fazla 50</strong> kaynak gÃ¶sterilir (Semantic Scholar â†’ OpenAlex fallback; Semantic Scholar Ã¶nceliklidir, yanÄ±t vermezse JSON yedeÄŸi kullanÄ±lÄ±r).<br>
    ğŸ”¹ Ortadaki Ã¶zet, makalenin kÄ±sa aÃ§Ä±klamasÄ±nÄ± gÃ¶sterir (Semantic Scholar Ã¶ncelikli; yoksa OpenAlex'ten veya JSON yedekten elde edilir).<br>
    ğŸ”¹ DÃ¼ÄŸÃ¼mlere tÄ±klayarak makale sayfasÄ±na gidebilirsiniz (Ã§ift tÄ±k).<br>
    ğŸ”¹ DÃ¼ÄŸÃ¼mler <strong>atÄ±f sayÄ±sÄ±na gÃ¶re</strong> bÃ¼yÃ¼r â€” ToplarÄ±n bÃ¼yÃ¼klÃ¼k farkÄ±, makalelerin aldÄ±ÄŸÄ± atÄ±f sayÄ±sÄ±na gÃ¶redir.<br>
  </div>

  <footer>Â© 2025 <b>Selim Ã–MÃœR</b> â€” <a href="mailto:omurselim@gmail.com">omurselim@gmail.com</a> â€” Ä°zinsiz kullanÄ±lamaz.</footer>

<script>
/* 
  DeÄŸiÅŸiklikler:
  - KaynakÃ§a limiti 50 (OpenAlex referenced_works per_page=50).
  - Semantic Scholar Ã¶ncelikli, baÅŸarÄ±sÄ±z ise exampleJson fallback.
  - En bÃ¼yÃ¼k dÃ¼ÄŸÃ¼m hover mesajÄ±: "Bu makale en fazla atÄ±f alan kaynaktÄ±r."
  - Ok ve kenar gÃ¶rÃ¼nÃ¼rlÃ¼ÄŸÃ¼ arttÄ±rÄ±ldÄ±.
*/

const PROXY = 'https://api.allorigins.win/raw?url='; // proxy for SS
const SS_TIMEOUT = 3500; // ms
const CACHE = new Map();

// --- example JSON fallback (basit Ã¶rnek; istersen gerÃ§ek yedeÄŸi buraya koyarÄ±m) ---
const exampleJsonData = {
  source: 'json_example',
  title: 'Ã–rnek Makale BaÅŸlÄ±ÄŸÄ± â€” JSON Yedek',
  year: 2000,
  doi: '10.0000/example',
  paperId: 'example:1',
  url: null,
  citationCount: 12,
  abstract: 'Bu bir Ã¶rnek yedek veridir. Semantic Scholar eriÅŸimi baÅŸarÄ±sÄ±z olduÄŸunda kullanÄ±lÄ±r.',
  references: [
    { title: 'Ã–rnek Ref 1', paperId: 'ex:ref1', doi: null, year:1999, citationCount: 5, url: null },
    { title: 'Ã–rnek Ref 2', paperId: 'ex:ref2', doi: null, year:1998, citationCount: 2, url: null }
  ],
  citations: [
    { title: 'Ã–rnek Cit 1', paperId: 'ex:cit1', doi: null, year:2001, citationCount: 3, url: null }
  ]
};
// ------------------------------------------------------------------

function timeoutPromise(ms) { return new Promise((_, rej) => setTimeout(()=>rej(new Error('timeout')), ms)); }
function sizeFromCitations(count){ const c = Math.max(0, Number(count)||0); return Math.round(6 + Math.sqrt(c)*4); } // nice sizing

// fetch via proxy -> safe parse
async function fetchJsonProxy(url){
  const attempt = PROXY + encodeURIComponent(url);
  const controller = new AbortController();
  const id = setTimeout(()=>controller.abort(), 12000);
  try{
    const res = await fetch(attempt, { signal: controller.signal });
    clearTimeout(id);
    if(!res.ok) throw new Error('HTTP ' + res.status);
    const txt = await res.text();
    if(!txt) throw new Error('Empty response from proxy');
    return JSON.parse(txt);
  } catch(e){
    clearTimeout(id);
    throw e;
  }
}

async function fetchOpenAlex(doi){
  const url = `https://api.openalex.org/works/https://doi.org/${encodeURIComponent(doi)}`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('OpenAlex HTTP ' + res.status);
  return await res.json();
}

// fetch referenced works for an OpenAlex work id, up to per_page (default 50 now)
async function fetchOpenAlexReferencedWorks(openalexWorkId, per_page = 50){
  try{
    const seg = openalexWorkId.split('/').pop();
    const url = `https://api.openalex.org/works/${encodeURIComponent(seg)}/referenced_works?per_page=${per_page}`;
    const res = await fetch(url);
    if(!res.ok) return [];
    const j = await res.json();
    return (j.results || []).map(r => r.id);
  } catch(e){
    console.warn('fetchOpenAlexReferencedWorks fail', e);
    return [];
  }
}

// fetch OpenAlex work details by id (works/Wxxxx)
async function fetchOpenAlexWorkById(openalexWorkId){
  try{
    const seg = openalexWorkId.split('/').pop();
    const url = `https://api.openalex.org/works/${encodeURIComponent(seg)}`;
    const res = await fetch(url);
    if(!res.ok) return null;
    return await res.json();
  }catch(e){ return null; }
}

// convert OpenAlex abstract_inverted_index to string
function openAlexAbstractToText(inv){
  try{
    if(!inv) return null;
    let maxPos = -1;
    for(const w in inv){ const arr = inv[w]; if(Array.isArray(arr)) arr.forEach(p => { if(p > maxPos) maxPos = p; }); }
    const out = new Array(maxPos+1);
    for(const w in inv){ const arr = inv[w]; if(Array.isArray(arr)) arr.forEach(pos => { out[pos] = w; }); }
    return out.filter(Boolean).join(' ');
  }catch(e){ return null; }
}

document.addEventListener('DOMContentLoaded', () => {
  const input = document.getElementById('paperInput');
  const searchButton = document.getElementById('searchButton');
  const sampleButton = document.getElementById('sampleButton');
  const spinner = document.getElementById('spinner');
  const status = document.getElementById('status');
  const leftEl = document.getElementById('leftNet');
  const rightEl = document.getElementById('rightNet');
  const topSummary = document.getElementById('topSummary');
  const savePng = document.getElementById('savePng');
  const savePdf = document.getElementById('savePdf');
  const themeBtn = document.getElementById('themeBtn');
  const yearFilter = document.getElementById('yearFilter');
  const infoBox = document.getElementById('infoBox');

  let leftNetwork = null, rightNetwork = null;
  let leftGraph = null, rightGraph = null;
  let currentData = null;

  themeBtn.onclick = ()=> { document.body.classList.toggle('dark'); themeBtn.textContent = document.body.classList.contains('dark') ? 'â˜€ï¸' : 'ğŸŒ™'; };

  sampleButton.onclick = () => { input.value = '10.1109/5.771073'; searchPaper(); };
  input.addEventListener('keyup', e => { if(e.key==='Enter') searchPaper(); });
  searchButton.onclick = searchPaper;

  savePng.onclick = async () => {
    if(!leftNetwork && !rightNetwork) return alert('Ã–nce grafik oluÅŸturun!');
    const leftCanvas = leftNetwork ? leftNetwork.canvas.frame.canvas : null;
    const rightCanvas = rightNetwork ? rightNetwork.canvas.frame.canvas : null;
    const w = (leftCanvas?leftCanvas.width:0) + (rightCanvas?rightCanvas.width:0);
    const h = Math.max(leftCanvas?leftCanvas.height:0, rightCanvas?rightCanvas.height:0);
    const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
    const ctx = tmp.getContext('2d');
    if(leftCanvas) ctx.drawImage(leftCanvas, 0, 0);
    if(rightCanvas) ctx.drawImage(rightCanvas, leftCanvas?leftCanvas.width:0, 0);
    const a = document.createElement('a'); a.href = tmp.toDataURL('image/png'); a.download = 'atif-citations-references.png'; a.click();
  };

  savePdf.onclick = async () => {
    if(!leftNetwork && !rightNetwork) return alert('Ã–nce grafik oluÅŸturun!');
    const leftCanvas = leftNetwork ? leftNetwork.canvas.frame.canvas : null;
    const rightCanvas = rightNetwork ? rightNetwork.canvas.frame.canvas : null;
    const w = (leftCanvas?leftCanvas.width:0) + (rightCanvas?rightCanvas.width:0);
    const h = Math.max(leftCanvas?leftCanvas.height:0, rightCanvas?rightCanvas.height:0);
    const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
    const ctx = tmp.getContext('2d');
    if(leftCanvas) ctx.drawImage(leftCanvas, 0, 0);
    if(rightCanvas) ctx.drawImage(rightCanvas, leftCanvas?leftCanvas.width:0, 0);
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation: 'landscape' });
    const img = tmp.toDataURL('image/png');
    const pw = pdf.internal.pageSize.getWidth(), ph = pdf.internal.pageSize.getHeight();
    pdf.addImage(img, 'PNG', 10, 10, pw-20, ph-20);
    pdf.save('atif-citations-references.pdf');
  };

  async function searchPaper(){
    const doi = input.value.trim();
    if(!doi){ status.textContent = 'âš ï¸ LÃ¼tfen DOI girin.'; return; }
    if(CACHE.has(doi)){
      currentData = CACHE.get(doi);
      renderAll(currentData);
      status.textContent = 'âš¡ Ã–nbellekten yÃ¼klendi.';
      return;
    }

    spinner.style.display = 'inline-block';
    status.textContent = 'ğŸ” Veriler Ã§ekiliyor (Semantic Scholar Ã¶ncelikli, OpenAlex yedeÄŸi)...';
    topSummary.innerHTML = 'KÄ±sa Ã¶zet: <i>YÃ¼kleniyor...</i>';

    // try Semantic Scholar first; if it fails, use exampleJsonData as fallback
    let ssResult = null;
    try{
      ssResult = await fetchJsonProxy(`https://api.semanticscholar.org/graph/v1/paper/DOI:${encodeURIComponent(doi)}?fields=title,year,authors,doi,paperId,url,citationCount,abstract,references.paperId,references.title,references.year,references.doi,citations.paperId,citations.title,citations.year,citations.doi`);
    }catch(e){
      console.warn('Semantic Scholar fetch failed, using JSON fallback:', e);
      // use example JSON as fallback (so UI doesn't fail)
      ssResult = null; // keep null so OpenAlex still attempted below; but we will use example if both fail
    }

    // try OpenAlex in parallel (but only if needed)
    let oxResult = null;
    try{
      oxResult = await Promise.race([ fetchOpenAlex(doi), timeoutPromise(SS_TIMEOUT).then(()=>null) ]);
    }catch(e){ oxResult = null; }

    // If both services failed to give useful data, use exampleJsonData
    if(!ssResult && !oxResult){
      console.warn('Both SS and OpenAlex failed â€” using example JSON data.');
      const finalData = exampleJsonData;
      CACHE.set(doi, finalData);
      currentData = finalData;
      renderAll(finalData);
      spinner.style.display = 'none';
      status.textContent = `âš ï¸ Semantic Scholar ve OpenAlex yanÄ±t vermedi â€” JSON yedeÄŸi yÃ¼klendi.`;
      return;
    }

    // Build finalData preferring SS when it contains refs/cits; else OpenAlex
    let finalData = null;
    if(ssResult && ( (Array.isArray(ssResult.citations) && ssResult.citations.length>0) || (Array.isArray(ssResult.references) && ssResult.references.length>0) )){
      finalData = {
        source: 'ss',
        title: ssResult.title,
        year: ssResult.year,
        doi: ssResult.doi,
        paperId: ssResult.paperId,
        url: ssResult.url || (ssResult.doi?`https://doi.org/${ssResult.doi}`:null),
        citationCount: ssResult.citationCount || 0,
        abstract: ssResult.abstract || null,
        references: (ssResult.references || []).map(r => ({
          title: r.title || r.reference?.title || 'BaÅŸlÄ±k',
          paperId: r.paperId || (r.reference && r.reference.paperId) || r.reference?.doi || null,
          doi: r.doi || r.reference?.doi || null,
          year: r.year || r.reference?.year || null,
          citationCount: r.citationCount || r.reference?.citationCount || 0,
          url: null
        })).slice(0,50), // enforce 50 limit
        citations: (ssResult.citations || []).map(c => ({
          title: c.title || c.citingPaper?.title || 'BaÅŸlÄ±k',
          paperId: c.paperId || c.citingPaper?.paperId || c.citingPaper?.doi || null,
          doi: c.doi || c.citingPaper?.doi || null,
          year: c.year || c.citingPaper?.year || null,
          citationCount: c.citationCount || c.citingPaper?.citationCount || 0,
          url: null
        }))
      };

      // If SS references is empty but we have OpenAlex, try fill references from OpenAlex (limit 50)
      if(finalData.references.length === 0 && oxResult && oxResult.id){
        try{
          const refIds = await fetchOpenAlexReferencedWorks(oxResult.id, 50);
          const fetched = [];
          for(let i=0;i<refIds.length;i+=25){
            const chunk = refIds.slice(i,i+25);
            const p = await Promise.all(chunk.map(id => fetchOpenAlexWorkById(id).catch(()=>null)));
            p.forEach(r => { if(r) fetched.push({ title: r.title, paperId: r.id, doi: r.doi||null, year: r.publication_year||null, citationCount: r.cited_by_count||0, url: r.primary_location?.source_url||null }); });
            await new Promise(r=>setTimeout(r,120));
          }
          if(fetched.length>0) finalData.references = fetched.slice(0,50);
          if(fetched.length>0) status.textContent += ' (OpenAlex references fallback kullanÄ±ldÄ± â€” 50 sÄ±nÄ±rÄ± uygulandÄ±)';
        }catch(e){ console.warn('fallback refs failed', e); }
      }

    } else if(oxResult && oxResult.id){
      // build from OpenAlex
      const base = {
        source: 'ox',
        title: oxResult.title,
        year: oxResult.publication_year,
        doi: input.value.trim(),
        paperId: oxResult.id,
        url: oxResult.open_access?.oa_url || `https://openalex.org/${oxResult.id.split('/').pop()}`,
        citationCount: oxResult.cited_by_count || 0,
        abstract: oxResult.abstract || openAlexAbstractToText(oxResult.abstract_inverted_index) || null,
        references: [],
        citations: []
      };
      try{
        const refIds = await fetchOpenAlexReferencedWorks(oxResult.id, 50);
        for(let i=0;i<refIds.length;i+=25){
          const chunk = refIds.slice(i,i+25);
          const promises = chunk.map(id => fetchOpenAlexWorkById(id).catch(()=>null));
          const results = await Promise.all(promises);
          results.forEach(r => { if(r) base.references.push({ title: r.title, paperId: r.id, doi: r.doi||null, year: r.publication_year||null, citationCount: r.cited_by_count||0, url: r.primary_location?.source_url || null }); });
          await new Promise(r=>setTimeout(r,120));
        }
      }catch(e){ console.warn('openalex referenced fetch fail', e); }
      try{
        const citesResp = await fetch(`https://api.openalex.org/works?filter=cites:${encodeURIComponent(oxResult.id)}&per_page=200`);
        if(citesResp.ok){
          const cj = await citesResp.json();
          (cj.results || []).forEach(r => base.citations.push({ title: r.title, paperId: r.id, doi: r.doi||null, year: r.publication_year||null, citationCount: r.cited_by_count||0, url: r.primary_location?.source_url || null }));
        }
      }catch(e){ console.warn('openalex cites fetch fail', e); }
      // enforce 50 limit
      base.references = base.references.slice(0,50);
      finalData = base;
    } else {
      // if we still have ssResult minimally, use that but enforce 50
      if(ssResult){
        finalData = {
          source: 'ss_min',
          title: ssResult.title,
          year: ssResult.year,
          doi: ssResult.doi,
          paperId: ssResult.paperId,
          url: ssResult.url || (ssResult.doi?`https://doi.org/${ssResult.doi}`:null),
          citationCount: ssResult.citationCount || 0,
          abstract: ssResult.abstract || null,
          references: (ssResult.references || []).map(r => ({ title: r.title || r.reference?.title || 'BaÅŸlÄ±k', paperId: r.paperId || r.reference?.paperId || null, doi: r.doi || r.reference?.doi || null, year: r.year || r.reference?.year || null, citationCount: r.citationCount || r.reference?.citationCount || 0, url: null })).slice(0,50),
          citations: (ssResult.citations || []).map(c => ({ title: c.title || c.citingPaper?.title || 'BaÅŸlÄ±k', paperId: c.paperId || c.citingPaper?.paperId || null, doi: c.doi || c.citingPaper?.doi || null, year: c.year || c.citingPaper?.year || null, citationCount: c.citationCount || c.citingPaper?.citationCount || 0, url: null }))
        };
      } else {
        // final fallback example
        finalData = exampleJsonData;
      }
    }

    // cache & render
    CACHE.set(input.value.trim(), finalData);
    currentData = finalData;
    renderAll(finalData);
    spinner.style.display = 'none';
    status.textContent = `âœ… "${finalData.title || input.value.trim()}" yÃ¼klendi. (refs: ${finalData.references.length}, cits: ${finalData.citations.length})`;
  } // end searchPaper

  // render summary + two graphs
  function renderAll(data){
    const abs = data.abstract ? (data.abstract.length>600 ? data.abstract.slice(0,600)+'â€¦' : data.abstract) : '<i>Ã–zet bulunamadÄ±.</i>';
    topSummary.innerHTML = `<strong style="font-size:0.95rem">${(data.title||'').substring(0,120)}</strong> (${data.year || '?'})<br><small>${abs}</small>`;

    const yearLimit = yearFilter.value === 'all' ? 0 : parseInt(yearFilter.value);
    const citList = (data.citations||[]).filter(x => !(x.year && yearLimit && x.year < yearLimit));
    const refList = (data.references||[]).filter(x => !(x.year && yearLimit && x.year < yearLimit));

    drawNetworkLeft(citList, data);
    drawNetworkRight(refList, data);
  }

  // utility: pick top-k nodes by citationCount for label display
  function chooseLabelledNodes(list){
    const n = list.length;
    if(n === 0) return new Set();
    const k = Math.max(12, Math.round(n * 0.12)); // reduce min to 12 to avoid overcrowd
    const sorted = [...list].sort((a,b)=> (Number(b.citationCount||0) - Number(a.citationCount||0)));
    const top = sorted.slice(0,k).map(x => x.paperId || x.id || x.doi || x.title);
    return new Set(top);
  }

  function drawNetworkLeft(citations, data){
    const nodes = [], edges = [];
    const mainId = data.paperId || data.doi || 'main';
    // show article title small on center node
    nodes.push({ id: mainId, label:`${(data.title||'').substring(0,60)}`, title: `${data.title||''}\n(${data.year||'?'})`, color:'#f0a30a', size: Math.max(12, sizeFromCitations(data.citationCount||0)), url: data.url, citationCount: data.citationCount||0 });

    // pick labelled nodes
    const labelledSet = chooseLabelledNodes(citations);

    // compute max citationCount among citations for hover detection
    let maxCitation = 0;
    citations.forEach(it => { const c = Number(it.citationCount||0); if(c>maxCitation) maxCitation = c; });

    citations.forEach(item=>{
      const id = item.paperId || item.doi || (item.title + '::' + Math.random().toString(36).slice(2,6));
      const showLabel = labelledSet.has(item.paperId || item.doi || id);
      nodes.push({ id, label: showLabel ? (item.title||'').substring(0,40) : '', title:`${item.title||''}\nYÄ±l:${item.year||'?'}`, color:'#34A853', size: sizeFromCitations(item.citationCount||0), url: item.doi?`https://doi.org/${item.doi}`: item.url || null, citationCount: item.citationCount||0 });
      edges.push({ from: id, to: mainId, color:{ color:'#34A853' }, arrows: { to: { enabled: true, type: 'arrow' } }, width:2.6 });
    });

    const uniq = {}; nodes.forEach(n => uniq[n.id] = n);
    const finalNodes = Object.values(uniq);

    const gdata = { nodes: new vis.DataSet(finalNodes), edges: new vis.DataSet(edges) };
    if(leftNetwork) leftNetwork.destroy();

    leftNetwork = new vis.Network(leftEl, gdata, {
      nodes:{ shape:'dot', font:{ size:10, color: 'var(--text)' } },
      edges:{ width:2.6, smooth:{ type:'dynamic' }, arrows:{ to:{ enabled:true, scaleFactor:1.2, type:'arrow' } } },
      physics:{ stabilization:false, barnesHut:{ gravitationalConstant:-2500, springLength:140, springConstant:0.02 } },
      interaction:{ hover:true, hoverConnectedEdges: true }
    });

    leftGraph = gdata;

    // store maxCitation for hover checks
    leftNetwork.body.data._maxCitation = maxCitation;

    leftNetwork.on('stabilizationIterationsDone', ()=> { try{ leftNetwork.physics.stop(); }catch(e){} });
    leftNetwork.on('click', params => {
      if(params.nodes.length){
        const node = leftGraph.nodes.get(params.nodes[0]);
        showInfo(node);
      } else hideInfo();
    });
    leftNetwork.on('doubleClick', params => { if(params.nodes.length){ const node = leftGraph.nodes.get(params.nodes[0]); if(node && node.url) window.open(node.url,'_blank'); } });

    leftNetwork.on('hoverNode', params => {
      const n = leftGraph.nodes.get(params.node);
      // temporarily show label if hidden
      if(n && !n.label) leftGraph.nodes.update({ id: n.id, label: (n.title||'').split('\n')[0].slice(0,40) });
      // if this node has the maximum citation, show special message
      if(n && Number(n.citationCount||0) === leftNetwork.body.data._maxCitation && leftNetwork.body.data._maxCitation>0){
        infoBox.style.display = 'block';
        infoBox.style.left = (leftEl.getBoundingClientRect().left + 12) + 'px';
        infoBox.style.top = (leftEl.getBoundingClientRect().top + 12) + 'px';
        infoBox.innerHTML = `<strong>Bu makale en fazla atÄ±f alan kaynaktÄ±r.</strong><br>${(n.title||'').split('\n')[0]}<br>AtÄ±f sayÄ±sÄ±: ${n.citationCount || 0}`;
      }
    });
    leftNetwork.on('blurNode', params => {
      const n = leftGraph.nodes.get(params.node);
      if(n){
        const shouldHave = labelledSet.has(n.id);
        if(!shouldHave) leftGraph.nodes.update({ id: n.id, label: '' });
      }
      hideInfo();
    });
  }

  function drawNetworkRight(references, data){
    const nodes = [], edges = [];
    const mainId = data.paperId || data.doi || 'main';
    nodes.push({ id: mainId, label:`${(data.title||'').substring(0,60)}`, title: `${data.title||''}\n(${data.year||'?'})`, color:'#f0a30a', size: Math.max(12, sizeFromCitations(data.citationCount||0)), url: data.url, citationCount: data.citationCount||0 });

    const labelledSet = chooseLabelledNodes(references);

    // compute max citationCount among references
    let maxCitation = 0;
    references.forEach(it => { const c = Number(it.citationCount||0); if(c>maxCitation) maxCitation = c; });

    references.forEach(item=>{
      const id = item.paperId || item.doi || (item.title + '::' + Math.random().toString(36).slice(2,6));
      const showLabel = labelledSet.has(item.paperId || item.doi || id);
      nodes.push({ id, label: showLabel ? (item.title||'').substring(0,40) : '', title:`${item.title||''}\nYÄ±l:${item.year||'?'}`, color:'#4285F4', size: sizeFromCitations(item.citationCount||0), url: item.doi?`https://doi.org/${item.doi}`: item.url || null, citationCount: item.citationCount||0 });
      edges.push({ from: mainId, to: id, color:{ color:'#4285F4' }, arrows: { to: { enabled: true, type: 'arrow' } }, width:2.6 });
    });

    const uniq = {}; nodes.forEach(n => uniq[n.id] = n);
    const finalNodes = Object.values(uniq);

    const gdata = { nodes: new vis.DataSet(finalNodes), edges: new vis.DataSet(edges) };
    if(rightNetwork) rightNetwork.destroy();

    rightNetwork = new vis.Network(rightEl, gdata, {
      nodes:{ shape:'dot', font:{ size:10, color: 'var(--text)' } },
      edges:{ width:2.6, smooth:{ type:'dynamic' }, arrows:{ to:{ enabled:true, scaleFactor:1.2, type:'arrow' } } },
      physics:{ stabilization:false, barnesHut:{ gravitationalConstant:-2200, springLength:140, springConstant:0.02 } },
      interaction:{ hover:true, hoverConnectedEdges: true }
    });

    rightGraph = gdata;

    rightNetwork.body.data._maxCitation = maxCitation;

    rightNetwork.on('stabilizationIterationsDone', ()=> { try{ rightNetwork.physics.stop(); }catch(e){} });
    rightNetwork.on('click', params => {
      if(params.nodes.length){
        const node = rightGraph.nodes.get(params.nodes[0]);
        showInfo(node);
      } else hideInfo();
    });
    rightNetwork.on('doubleClick', params => { if(params.nodes.length){ const node = rightGraph.nodes.get(params.nodes[0]); if(node && node.url) window.open(node.url,'_blank'); } });

    rightNetwork.on('hoverNode', params => {
      const n = rightGraph.nodes.get(params.node);
      if(n && !n.label) rightGraph.nodes.update({ id: n.id, label: (n.title||'').split('\n')[0].slice(0,40) });
      if(n && Number(n.citationCount||0) === rightNetwork.body.data._maxCitation && rightNetwork.body.data._maxCitation>0){
        infoBox.style.display = 'block';
        infoBox.style.left = (rightEl.getBoundingClientRect().left + 12) + 'px';
        infoBox.style.top = (rightEl.getBoundingClientRect().top + 12) + 'px';
        infoBox.innerHTML = `<strong>Bu makale en fazla atÄ±f alan kaynaktÄ±r.</strong><br>${(n.title||'').split('\n')[0]}<br>AtÄ±f sayÄ±sÄ±: ${n.citationCount || 0}`;
      }
    });
    rightNetwork.on('blurNode', params => {
      const n = rightGraph.nodes.get(params.node);
      if(n){
        const shouldHave = labelledSet.has(n.id);
        if(!shouldHave) rightGraph.nodes.update({ id: n.id, label: '' });
      }
      hideInfo();
    });
  }

  function showInfo(node){
    infoBox.style.display = 'block';
    infoBox.style.left = '12px';
    infoBox.style.top = '12px';
    infoBox.innerHTML = `<strong>${node.label || (node.title||'BaÅŸlÄ±k').split('\n')[0]}</strong><br>${(node.title||'')}<br>${node.url? `<a href="${node.url}" target="_blank">Makale sayfasÄ±</a>` : ''}`;
  }
  function hideInfo(){ infoBox.style.display = 'none'; }

  // re-render on year filter change
  yearFilter.addEventListener('change', ()=>{ if(currentData) renderAll(currentData); });

  // expose debug
  window.searchPaper = () => { document.getElementById('searchButton').click(); };

}); // DOMContentLoaded end
</script>
</body>
</html>
