<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>By Selim - AtÄ±f Zinciri GÃ¶rselleÅŸtirici</title>

<!-- vis.js -->
<script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css" />

<!-- jspdf for export -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
:root{
  --bg: linear-gradient(135deg,#f7f9ff,#e9eeff);
  --accent:#2b4eff; --shadow: rgba(43,78,255,0.15);
  --card:#fff; --text:#111;
}
body.dark{ --bg: linear-gradient(135deg,#0f1116,#1a1d23); --accent:#00bfff; --card:#1f1f1f; --text:#eee; --shadow: rgba(0,191,255,0.18); }
body{ margin:0; font-family:"Segoe UI",sans-serif; background:var(--bg); color:var(--text); transition:0.35s; text-align:center; }
h1{ margin:18px 0; color:var(--accent); text-shadow:1px 1px 3px rgba(0,0,0,0.15); }
#controls{ margin:20px; display:flex; flex-wrap:wrap; gap:10px; justify-content:center; align-items:center; }
input,select,button{ padding:10px 14px; font-size:14px; border-radius:8px; border:1px solid #ccc; }
button{ background:var(--accent); color:#fff; border:none; cursor:pointer; box-shadow:0 3px 6px var(--shadow); }
#topSummary { max-width:1000px; margin:10px auto; background:var(--card); padding:12px 16px; border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,0.06); text-align:left; font-size:0.95rem; }
#networks { display:flex; gap:12px; justify-content:center; align-items:flex-start; width:95%; margin:10px auto; }
.networkCard { flex:1; min-width:300px; background:var(--card); border-radius:12px; padding:10px; box-shadow:0 10px 24px rgba(0,0,0,0.04); position:relative; overflow:hidden; }
.networkHeader { font-weight:600; color:var(--accent); margin-bottom:8px; text-align:left; }
#leftNet, #rightNet { width:100%; height:520px; border-radius:10px; background:transparent; }
#status{ margin:10px; font-weight:500; min-height:20px; }
#spinner{ display:none; border:4px solid #f3f3f3; border-top:4px solid var(--accent); border-radius:50%; width:30px; height:30px; margin:6px auto; animation:spin 1s linear infinite; }
@keyframes spin{ to{ transform:rotate(360deg); } }
#notes{ background: rgba(43,78,255,0.07); padding:12px; border-radius:10px; max-width:900px; margin:10px auto; font-size:0.9em; text-align:left; }
footer{ margin:25px 0; font-size:0.8em; color:gray; }
footer a{ color:var(--accent); text-decoration:none; }

/* small translucent hint in top-right corner of each network card */
.zoomHint {
  position: absolute;
  right: 12px;
  top: 12px;
  z-index: 40;
  background: rgba(255,255,255,0.75);
  padding: 6px 10px;
  border-radius: 8px;
  font-size: 12px;
  color: #333;
  box-shadow: 0 6px 18px rgba(0,0,0,0.06);
  pointer-events: none;
}
body.dark .zoomHint { background: rgba(20,20,20,0.65); color: #eee; }

.infoBox { position:absolute; left:12px; top:12px; z-index:20; display:none; max-width:320px; background:rgba(255,255,255,0.96); padding:10px 12px; border-radius:8px; box-shadow:0 8px 20px rgba(0,0,0,0.08); text-align:left; font-size:13px; }
body.dark .infoBox{ background:rgba(20,20,20,0.95); color:#eee; }

@media (max-width:980px){
  #networks { flex-direction:column; }
  #leftNet, #rightNet { height:420px; }
  .zoomHint { display:none; } /* hide hint on small screens */
}
</style>
</head>
<body>
  <h1>By Selim - AtÄ±f Zinciri GÃ¶rselleÅŸtirici</h1>

  <div id="controls">
    <input id="paperInput" placeholder="Makale DOI'si (Ã¶rn: 10.1109/5.771073)" style="width:420px">
    <button id="searchButton">Ara</button>
    <button id="sampleButton">ğŸ² Ã–rnek DOI</button>
    <select id="yearFilter">
      <option value="all">TÃ¼m YÄ±llar</option>
      <option value="2010">2010+</option>
      <option value="2015">2015+</option>
      <option value="2020">2020+</option>
    </select>
    <button id="savePng">ğŸ’¾ PNG</button>
    <button id="savePdf">ğŸ“„ PDF</button>
    <button id="themeBtn">ğŸŒ™ Gece Modu</button>
  </div>

  <div id="spinner"></div>
  <div id="status">HazÄ±r â€” DOI girip Ara'ya basÄ±n.</div>

  <div id="topSummary"> <!-- summary will be injected here --> KÄ±sa Ã¶zet: <i>HenÃ¼z makale yÃ¼klenmedi.</i></div>

  <div id="networks">
    <div class="networkCard">
      <div class="networkHeader">AtÄ±flar (Sana atÄ±f yapan makaleler) â€” YeÅŸil</div>
      <div class="zoomHint">ğŸ–±ï¸ Fare tekerleÄŸiyle yakÄ±nlaÅŸtÄ±rÄ±n Â· SÃ¼rÃ¼kleyin</div>
      <div id="leftNet"></div>
    </div>
    <div class="networkCard">
      <div class="networkHeader">KaynakÃ§alar (KÃ¶k makalenin kullandÄ±klarÄ±) â€” Mavi</div>
      <div class="zoomHint">ğŸ–±ï¸ Fare tekerleÄŸiyle yakÄ±nlaÅŸtÄ±rÄ±n Â· SÃ¼rÃ¼kleyin</div>
      <div id="rightNet"></div>
    </div>
  </div>

  <div class="infoBox" id="infoBox"></div>

  <div id="notes">
    ğŸ”¹ Sol grafik: o makaleye atÄ±f yapan Ã§alÄ±ÅŸmalar (citations).<br>
    ğŸ”¹ SaÄŸ grafik: makalenin kaynakÃ§asÄ± (references). Bu senin iÃ§in Ã¶zellikle Ã¶nemli â€” ayrÄ± panelde gÃ¶sterildi.<br>
    ğŸ”¹ Ortadaki Ã¶zet, makalenin kÄ±sa aÃ§Ä±klamasÄ±nÄ± gÃ¶sterir (Semantic Scholar Ã¶ncelikli; yoksa OpenAlex'ten elde edilir).<br>
    ğŸ”¹ DÃ¼ÄŸÃ¼mlere tÄ±klayarak makale sayfasÄ±na gidebilirsiniz (Ã§ift tÄ±k).<br>
    ğŸ”¹ DÃ¼ÄŸÃ¼mler atÄ±f sayÄ±sÄ±na gÃ¶re boyutlanÄ±r: <code>size = 5 + Math.sqrt(citationCount) * 4</code>.<br>
  </div>

  <footer>Â© 2025 <b>Selim Ã–MÃœR</b> â€” <a href="mailto:omurselim@gmail.com">omurselim@gmail.com</a> â€” Ä°zinsiz kullanÄ±lamaz.</footer>

<script>
/* 
  GÃ¼ncellenmiÅŸ: OpenAlex referenced_works -> doÄŸru API endpoint kullanÄ±mÄ±,
  zoomHint eklendi. TasarÄ±m ve Ã§ekirdek mantÄ±k korunmuÅŸtur.
*/

const PROXY = 'https://api.allorigins.win/raw?url='; // proxy for SS
const SS_TIMEOUT = 3500; // ms
const CACHE = new Map();

function timeoutPromise(ms) { return new Promise((_, rej) => setTimeout(()=>rej(new Error('timeout')), ms)); }
function sizeFromCitations(count){ const c = Math.max(0, Number(count)||0); return Math.round(5 + Math.sqrt(c)*4); }

// fetch via proxy -> safe parse
async function fetchJsonProxy(url){
  const attempt = PROXY + encodeURIComponent(url);
  const controller = new AbortController();
  const id = setTimeout(()=>controller.abort(), 10000);
  try{
    const res = await fetch(attempt, { signal: controller.signal });
    clearTimeout(id);
    if(!res.ok) throw new Error('HTTP ' + res.status);
    const txt = await res.text();
    if(!txt) throw new Error('Empty response from proxy');
    return JSON.parse(txt);
  } catch(e){
    clearTimeout(id);
    throw e;
  }
}

async function fetchOpenAlex(doi){
  const url = `https://api.openalex.org/works/https://doi.org/${encodeURIComponent(doi)}`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('OpenAlex HTTP ' + res.status);
  return await res.json();
}

// fetch OpenAlex work by OpenAlex id (Wxxxx) using API path
async function fetchOpenAlexWorkById(openalexWorkId){
  // openalexWorkId may be a URL or id; get last segment
  const seg = openalexWorkId.split('/').pop();
  const apiUrl = `https://api.openalex.org/works/${encodeURIComponent(seg)}`;
  const res = await fetch(apiUrl);
  if(!res.ok) return null;
  return await res.json();
}

// convert OpenAlex abstract_inverted_index to string
function openAlexAbstractToText(inv){
  try{
    if(!inv) return null;
    let maxPos = -1;
    for(const w in inv){ const arr = inv[w]; if(Array.isArray(arr)) arr.forEach(p => { if(p > maxPos) maxPos = p; }); }
    const out = new Array(maxPos+1);
    for(const w in inv){ const arr = inv[w]; if(Array.isArray(arr)) arr.forEach(pos => { out[pos] = w; }); }
    return out.filter(Boolean).join(' ');
  }catch(e){ return null; }
}

document.addEventListener('DOMContentLoaded', () => {
  const input = document.getElementById('paperInput');
  const searchButton = document.getElementById('searchButton');
  const sampleButton = document.getElementById('sampleButton');
  const spinner = document.getElementById('spinner');
  const status = document.getElementById('status');
  const leftEl = document.getElementById('leftNet');
  const rightEl = document.getElementById('rightNet');
  const topSummary = document.getElementById('topSummary');
  const savePng = document.getElementById('savePng');
  const savePdf = document.getElementById('savePdf');
  const themeBtn = document.getElementById('themeBtn');
  const yearFilter = document.getElementById('yearFilter');
  const infoBox = document.getElementById('infoBox');

  let leftNetwork = null, rightNetwork = null;
  let leftGraph = null, rightGraph = null;
  let currentData = null;

  themeBtn.onclick = ()=> { document.body.classList.toggle('dark'); themeBtn.textContent = document.body.classList.contains('dark') ? 'â˜€ï¸' : 'ğŸŒ™'; };

  sampleButton.onclick = () => { input.value = '10.1109/5.771073'; searchPaper(); };
  input.addEventListener('keyup', e => { if(e.key==='Enter') searchPaper(); });
  searchButton.onclick = searchPaper;

  savePng.onclick = async () => {
    if(!leftNetwork && !rightNetwork) return alert('Ã–nce grafik oluÅŸturun!');
    const leftCanvas = leftNetwork ? leftNetwork.canvas.frame.canvas : null;
    const rightCanvas = rightNetwork ? rightNetwork.canvas.frame.canvas : null;
    const w = (leftCanvas?leftCanvas.width:0) + (rightCanvas?rightCanvas.width:0);
    const h = Math.max(leftCanvas?leftCanvas.height:0, rightCanvas?rightCanvas.height:0);
    const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
    const ctx = tmp.getContext('2d');
    if(leftCanvas) ctx.drawImage(leftCanvas, 0, 0);
    if(rightCanvas) ctx.drawImage(rightCanvas, leftCanvas?leftCanvas.width:0, 0);
    const a = document.createElement('a'); a.href = tmp.toDataURL('image/png'); a.download = 'atif-citations-references.png'; a.click();
  };

  savePdf.onclick = async () => {
    if(!leftNetwork && !rightNetwork) return alert('Ã–nce grafik oluÅŸturun!');
    const leftCanvas = leftNetwork ? leftNetwork.canvas.frame.canvas : null;
    const rightCanvas = rightNetwork ? rightNetwork.canvas.frame.canvas : null;
    const w = (leftCanvas?leftCanvas.width:0) + (rightCanvas?rightCanvas.width:0);
    const h = Math.max(leftCanvas?leftCanvas.height:0, rightCanvas?rightCanvas.height:0);
    const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
    const ctx = tmp.getContext('2d');
    if(leftCanvas) ctx.drawImage(leftCanvas, 0, 0);
    if(rightCanvas) ctx.drawImage(rightCanvas, leftCanvas?leftCanvas.width:0, 0);
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation: 'landscape' });
    const img = tmp.toDataURL('image/png');
    const pw = pdf.internal.pageSize.getWidth(), ph = pdf.internal.pageSize.getHeight();
    pdf.addImage(img, 'PNG', 10, 10, pw-20, ph-20);
    pdf.save('atif-citations-references.pdf');
  };

  async function searchPaper(){
    const doi = input.value.trim();
    if(!doi){ status.textContent = 'âš ï¸ LÃ¼tfen DOI girin.'; return; }
    if(CACHE.has(doi)){
      currentData = CACHE.get(doi);
      renderAll(currentData);
      status.textContent = 'âš¡ Ã–nbellekten yÃ¼klendi.';
      return;
    }

    spinner.style.display = 'inline-block';
    status.textContent = 'ğŸ” Veriler Ã§ekiliyor (SS + OpenAlex)...';
    topSummary.innerHTML = 'KÄ±sa Ã¶zet: <i>YÃ¼kleniyor...</i>';

    // parallel requests
    const ssPromise = (async ()=> {
      try{
        return await fetchJsonProxy(`https://api.semanticscholar.org/graph/v1/paper/DOI:${encodeURIComponent(doi)}?fields=title,year,authors,doi,paperId,url,citationCount,abstract,references.paperId,references.title,references.year,references.doi,citations.paperId,citations.title,citations.year,citations.doi`);
      }catch(e){ console.warn('SS fail', e); return null; }
    })();
    const oxPromise = (async ()=> {
      try{ return await fetchOpenAlex(doi); }catch(e){ console.warn('OX fail', e); return null; }
    })();

    let ssResult = null, oxResult = null;
    try {
      ssResult = await Promise.race([ ssPromise, timeoutPromise(SS_TIMEOUT).then(()=>{ throw new Error('ss-timeout'); }) ]).catch(e=>{ console.warn('ss race err', e); return null; });
    } catch(e){ ssResult = null; }
    try { oxResult = await Promise.race([ oxPromise, timeoutPromise(SS_TIMEOUT).then(()=>null) ]); } catch(e){ oxResult = null; }

    if(!ssResult && !oxResult){
      try{ ssResult = await ssPromise; } catch(e){ ssResult = ssResult || null; }
      try{ oxResult = await oxPromise; } catch(e){ oxResult = oxResult || null; }
    }

    let finalData = null;
    // Prefer SS if it has citations or references
    if(ssResult && ( (Array.isArray(ssResult.citations) && ssResult.citations.length>0) || (Array.isArray(ssResult.references) && ssResult.references.length>0) )){
      finalData = {
        source: 'ss',
        title: ssResult.title,
        year: ssResult.year,
        doi: ssResult.doi,
        paperId: ssResult.paperId,
        url: ssResult.url || (ssResult.doi?`https://doi.org/${ssResult.doi}`:null),
        citationCount: ssResult.citationCount || 0,
        abstract: ssResult.abstract || null,
        references: (ssResult.references || []).map(r => ({
          title: r.title || r.reference?.title || 'BaÅŸlÄ±k',
          paperId: r.paperId || (r.reference && r.reference.paperId) || r.reference?.doi || null,
          doi: r.doi || r.reference?.doi || null,
          year: r.year || r.reference?.year || null,
          citationCount: r.citationCount || r.reference?.citationCount || 0,
          url: null
        })),
        citations: (ssResult.citations || []).map(c => ({
          title: c.title || c.citingPaper?.title || 'BaÅŸlÄ±k',
          paperId: c.paperId || c.citingPaper?.paperId || c.citingPaper?.doi || null,
          doi: c.doi || c.citingPaper?.doi || null,
          year: c.year || c.citingPaper?.year || null,
          citationCount: c.citationCount || c.citingPaper?.citationCount || 0,
          url: null
        }))
      };

      // If SS references is empty but we have OpenAlex, try to fill references from OpenAlex (using OpenAlex API)
      if(finalData.references.length === 0 && oxResult && oxResult.id){
        try{
          const refs = (oxResult.referenced_works || []).slice(0,200);
          const fetched = [];
          for(let i=0;i<refs.length;i+=25){
            const chunk = refs.slice(i,i+25);
            const p = await Promise.all(chunk.map(id => fetchOpenAlexWorkById(id).catch(()=>null)));
            p.forEach(r=>{ if(r) fetched.push({ title: r.title, paperId: r.id, doi: r.doi||null, year: r.publication_year||null, citationCount: r.cited_by_count||0, url: r.primary_location?.source_url||null }); });
            await new Promise(r=>setTimeout(r,120));
          }
          if(fetched.length>0) finalData.references = fetched;
          if(fetched.length>0) status.textContent += ' (OpenAlex references fallback kullanÄ±ldÄ±)';
        }catch(e){ console.warn('fallback refs failed', e); }
      }

    } else if(oxResult && oxResult.id){
      // build from OpenAlex (preferred if SS lacks)
      const base = {
        source: 'ox',
        title: oxResult.title,
        year: oxResult.publication_year,
        doi: input.value.trim(),
        paperId: oxResult.id,
        url: oxResult.open_access?.oa_url || `https://openalex.org/${oxResult.id.split('/').pop()}`,
        citationCount: oxResult.cited_by_count || 0,
        abstract: oxResult.abstract || openAlexAbstractToText(oxResult.abstract_inverted_index) || null,
        references: [],
        citations: []
      };
      // fetch referenced works metadata batched (use OpenAlex API)
      const refs = (oxResult.referenced_works || []).slice(0,200);
      for(let i=0;i<refs.length;i+=25){
        const chunk = refs.slice(i,i+25);
        const promises = chunk.map(id => fetchOpenAlexWorkById(id).catch(()=>null));
        const results = await Promise.all(promises);
        results.forEach(r => { if(r) base.references.push({ title: r.title, paperId: r.id, doi: r.doi||null, year: r.publication_year||null, citationCount: r.cited_by_count||0, url: r.primary_location?.source_url || null }); });
        await new Promise(r=>setTimeout(r,120));
      }
      try{
        const citesResp = await fetch(`https://api.openalex.org/works?filter=cites:${encodeURIComponent(oxResult.id)}&per_page=200`);
        if(citesResp.ok){
          const cj = await citesResp.json();
          (cj.results || []).forEach(r => base.citations.push({ title: r.title, paperId: r.id, doi: r.doi||null, year: r.publication_year||null, citationCount: r.cited_by_count||0, url: r.primary_location?.source_url || null }));
        }
      }catch(e){ console.warn('openalex cites fetch fail', e); }
      finalData = base;
    } else if(ssResult){
      // minimal SS fallback
      finalData = {
        source: 'ss_min',
        title: ssResult.title,
        year: ssResult.year,
        doi: ssResult.doi,
        paperId: ssResult.paperId,
        url: ssResult.url || (ssResult.doi?`https://doi.org/${ssResult.doi}`:null),
        citationCount: ssResult.citationCount || 0,
        abstract: ssResult.abstract || null,
        references: (ssResult.references || []).map(r => ({ title: r.title || r.reference?.title || 'BaÅŸlÄ±k', paperId: r.paperId || r.reference?.paperId || null, doi: r.doi || r.reference?.doi || null, year: r.year || r.reference?.year || null, citationCount: r.citationCount || r.reference?.citationCount || 0, url: null })),
        citations: (ssResult.citations || []).map(c => ({ title: c.title || c.citingPaper?.title || 'BaÅŸlÄ±k', paperId: c.paperId || c.citingPaper?.paperId || null, doi: c.doi || c.citingPaper?.doi || null, year: c.year || c.citingPaper?.year || null, citationCount: c.citationCount || c.citingPaper?.citationCount || 0, url: null }))
      };
    } else {
      spinner.style.display = 'none';
      status.textContent = 'âŒ Veri alÄ±namadÄ±: Kaynaklar yanÄ±t vermedi.';
      topSummary.innerHTML = 'KÄ±sa Ã¶zet: <i>Ã–zet alÄ±namadÄ±.</i>';
      return;
    }

    // cache & render
    CACHE.set(input.value.trim(), finalData);
    currentData = finalData;
    renderAll(finalData);
    spinner.style.display = 'none';
    status.textContent = `âœ… "${finalData.title || input.value.trim()}" yÃ¼klendi. (refs: ${finalData.references.length}, cits: ${finalData.citations.length})`;
  } // end searchPaper

  // render summary + two graphs
  function renderAll(data){
    const abs = data.abstract ? (data.abstract.length>600 ? data.abstract.slice(0,600)+'â€¦' : data.abstract) : '<i>Ã–zet bulunamadÄ±.</i>';
    topSummary.innerHTML = `<strong>${data.title || ''}</strong> (${data.year || '?'})<br><small>${abs}</small>`;

    const yearLimit = yearFilter.value === 'all' ? 0 : parseInt(yearFilter.value);
    const citList = (data.citations||[]).filter(x => !(x.year && yearLimit && x.year < yearLimit));
    const refList = (data.references||[]).filter(x => !(x.year && yearLimit && x.year < yearLimit));

    drawNetworkLeft(citList, data);
    drawNetworkRight(refList, data);
  }

  // utility: pick top-k nodes by citationCount for label display
  function chooseLabelledNodes(list){
    const n = list.length;
    if(n === 0) return new Set();
    const k = Math.max(20, Math.round(n * 0.12)); // top 12% or at least 20
    const sorted = [...list].sort((a,b)=> (Number(b.citationCount||0) - Number(a.citationCount||0)));
    const top = sorted.slice(0,k).map(x => x.paperId || x.id || x.doi || x.title);
    return new Set(top);
  }

  function drawNetworkLeft(citations, data){
    const nodes = [], edges = [];
    const mainId = data.paperId || data.doi || 'main';
    nodes.push({ id: mainId, label:`[ANA]\n${(data.title||'').substring(0,40)}...`, title: `${data.title||''}\n(${data.year||'?'})`, color:'#f0a30a', size: sizeFromCitations(data.citationCount||0), url: data.url });

    // pick labelled nodes
    const labelledSet = chooseLabelledNodes(citations);

    citations.forEach(item=>{
      const id = item.paperId || item.doi || (item.title + '::' + Math.random().toString(36).slice(2,6));
      const showLabel = labelledSet.has(item.paperId || item.doi || id);
      nodes.push({ id, label: showLabel ? (item.title||'').substring(0,40) : '', title:`${item.title||''}\nYÄ±l:${item.year||'?'}`, color:'#34A853', size: sizeFromCitations(item.citationCount||0), url: item.doi?`https://doi.org/${item.doi}`: item.url || null, citationCount: item.citationCount||0 });
      edges.push({ from: id, to: mainId, color:{ color:'#34A853' } });
    });

    const uniq = {}; nodes.forEach(n => uniq[n.id] = n);
    const finalNodes = Object.values(uniq);

    const gdata = { nodes: new vis.DataSet(finalNodes), edges: new vis.DataSet(edges) };
    if(leftNetwork) leftNetwork.destroy();

    leftNetwork = new vis.Network(leftEl, gdata, {
      nodes:{ shape:'dot', font:{ size:10, color: 'var(--text)' } },
      edges:{ width:1.6, smooth:{ type:'dynamic' }, arrows:{ to:{ enabled:true, scaleFactor:0.5 } } },
      physics:{ stabilization:false, barnesHut:{ gravitationalConstant:-2500, springLength:140, springConstant:0.02 } },
      interaction:{ hover:true, hoverConnectedEdges: true }
    });

    leftGraph = gdata;

    leftNetwork.on('stabilizationIterationsDone', ()=> { try{ leftNetwork.physics.stop(); }catch(e){} });
    leftNetwork.on('click', params => {
      if(params.nodes.length){
        const node = leftGraph.nodes.get(params.nodes[0]);
        showInfo(node);
      } else hideInfo();
    });
    leftNetwork.on('doubleClick', params => { if(params.nodes.length){ const node = leftGraph.nodes.get(params.nodes[0]); if(node && node.url) window.open(node.url,'_blank'); } });

    // when user hovers a node, temporarily show its label if it was hidden
    leftNetwork.on('hoverNode', params => {
      const n = leftGraph.nodes.get(params.node);
      if(n && !n.label){
        leftGraph.nodes.update({ id: n.id, label: (n.title||'').split('\n')[0].slice(0,40) });
      }
    });
    leftNetwork.on('blurNode', params => {
      const n = leftGraph.nodes.get(params.node);
      if(n){
        const shouldHave = labelledSet.has(n.id);
        if(!shouldHave) leftGraph.nodes.update({ id: n.id, label: '' });
      }
    });
  }

  function drawNetworkRight(references, data){
    const nodes = [], edges = [];
    const mainId = data.paperId || data.doi || 'main';
    nodes.push({ id: mainId, label:`[ANA]\n${(data.title||'').substring(0,40)}...`, title: `${data.title||''}\n(${data.year||'?'})`, color:'#f0a30a', size: sizeFromCitations(data.citationCount||0), url: data.url });

    const labelledSet = chooseLabelledNodes(references);

    references.forEach(item=>{
      const id = item.paperId || item.doi || (item.title + '::' + Math.random().toString(36).slice(2,6));
      const showLabel = labelledSet.has(item.paperId || item.doi || id);
      nodes.push({ id, label: showLabel ? (item.title||'').substring(0,40) : '', title:`${item.title||''}\nYÄ±l:${item.year||'?'}`, color:'#4285F4', size: sizeFromCitations(item.citationCount||0), url: item.doi?`https://doi.org/${item.doi}`: item.url || null, citationCount: item.citationCount||0 });
      edges.push({ from: mainId, to: id, color:{ color:'#4285F4' } });
    });

    const uniq = {}; nodes.forEach(n => uniq[n.id] = n);
    const finalNodes = Object.values(uniq);

    const gdata = { nodes: new vis.DataSet(finalNodes), edges: new vis.DataSet(edges) };
    if(rightNetwork) rightNetwork.destroy();

    rightNetwork = new vis.Network(rightEl, gdata, {
      nodes:{ shape:'dot', font:{ size:10, color: 'var(--text)' } },
      edges:{ width:1.6, smooth:{ type:'dynamic' }, arrows:{ to:{ enabled:true, scaleFactor:0.5 } } },
      physics:{ stabilization:false, barnesHut:{ gravitationalConstant:-2200, springLength:140, springConstant:0.02 } },
      interaction:{ hover:true, hoverConnectedEdges: true }
    });

    rightGraph = gdata;

    rightNetwork.on('stabilizationIterationsDone', ()=> { try{ rightNetwork.physics.stop(); }catch(e){} });
    rightNetwork.on('click', params => {
      if(params.nodes.length){
        const node = rightGraph.nodes.get(params.nodes[0]);
        showInfo(node);
      } else hideInfo();
    });
    rightNetwork.on('doubleClick', params => { if(params.nodes.length){ const node = rightGraph.nodes.get(params.nodes[0]); if(node && node.url) window.open(node.url,'_blank'); } });

    // hover show behaviour for hidden labels
    rightNetwork.on('hoverNode', params => {
      const n = rightGraph.nodes.get(params.node);
      if(n && !n.label){
        rightGraph.nodes.update({ id: n.id, label: (n.title||'').split('\n')[0].slice(0,40) });
      }
    });
    rightNetwork.on('blurNode', params => {
      const n = rightGraph.nodes.get(params.node);
      if(n){
        const shouldHave = labelledSet.has(n.id);
        if(!shouldHave) rightGraph.nodes.update({ id: n.id, label: '' });
      }
    });
  }

  function showInfo(node){
    infoBox.style.display = 'block';
    infoBox.innerHTML = `<strong>${node.label || (node.title||'BaÅŸlÄ±k').split('\n')[0]}</strong><br>${(node.title||'')}<br>${node.url? `<a href="${node.url}" target="_blank">Makale sayfasÄ±</a>` : ''}`;
  }
  function hideInfo(){ infoBox.style.display = 'none'; }

  // re-render on year filter change
  yearFilter.addEventListener('change', ()=>{ if(currentData) renderAll(currentData); });

  // expose debug
  window.searchPaper = () => { document.getElementById('searchButton').click(); };

}); // DOMContentLoaded end
</script>
</body>
</html>
