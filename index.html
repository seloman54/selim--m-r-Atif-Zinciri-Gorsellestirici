<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>By Selim - AtÄ±f Zinciri GÃ¶rselleÅŸtirici</title>

<!-- vis.js -->
<script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css">

<!-- html2canvas + jspdf for export -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
:root{
  --bg: linear-gradient(135deg,#f7f9ff,#e9eeff);
  --accent:#2b4eff; --shadow: rgba(43,78,255,0.15);
  --card:#fff; --text:#111;
}
body.dark{ --bg: linear-gradient(135deg,#0f1116,#1a1d23); --accent:#00bfff; --card:#1f1f1f; --text:#eee; --shadow: rgba(0,191,255,0.18); }
body{ margin:0; font-family:"Segoe UI",sans-serif; background:var(--bg); color:var(--text); transition:0.35s; text-align:center; }
h1{ margin:18px 0; color:var(--accent); text-shadow:1px 1px 3px rgba(0,0,0,0.15);}
#controls{ display:flex; flex-wrap:wrap; gap:10px; justify-content:center; margin:12px; align-items:center; }
input,select,button{ padding:10px 12px; border-radius:8px; border:1px solid #ccc; font-size:14px; }
button{ background:var(--accent); color:#fff; border:none; cursor:pointer; box-shadow:0 3px 6px var(--shadow); }
#network{ width:90%; height:620px; margin:12px auto; border-radius:14px; background:var(--card); box-shadow:0 0 25px var(--shadow); position:relative; }
#status{ margin:8px; font-weight:600; min-height:20px; }
#notes{ background: rgba(43,78,255,0.07); max-width:760px; margin:8px auto; padding:12px; border-radius:10px; font-size:14px; text-align:left; }
footer{ margin:18px 0; font-size:13px; color:gray; }
footer a{ color:var(--accent); text-decoration:none; }
#centerButton{ position:absolute; right:12px; top:12px; z-index:8; padding:6px 10px; border-radius:8px; border:none; background:var(--accent); color:#fff; cursor:pointer;}
#spinner{ display:none; border:4px solid #f3f3f3; border-top:4px solid var(--accent); border-radius:50%; width:30px; height:30px; margin:10px auto; animation:spin 1s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }
#controls .small { padding:6px 8px; font-size:0.95rem; }
.toggle-edges { opacity:0.9; }
@media (max-width:720px){ #network{ height:520px; } input{ width:200px; } }
</style>
</head>
<body>
  <h1>By Selim - AtÄ±f Zinciri GÃ¶rselleÅŸtirici</h1>

  <div id="controls">
    <input id="paperInput" placeholder="DOI girin (Ã¶rn: 10.1109/5.771073)" style="width:360px">
    <button id="searchButton">Ara</button>
    <button id="sampleButton">ğŸ² Ã–rnek DOI</button>

    <select id="yearFilter" class="small">
      <option value="all">TÃ¼m YÄ±llar</option>
      <option value="2010">2010+</option>
      <option value="2015">2015+</option>
      <option value="2020">2020+</option>
    </select>

    <div class="side-controls">
      <button id="savePNG" class="small">ğŸ’¾ PNG</button>
      <button id="savePDF" class="small">ğŸ“„ PDF</button>
      <button id="themeBtn" class="small">ğŸŒ™</button>
      <button id="toggleEdges" class="small toggle-edges" title="BaÄŸlantÄ±larÄ± gizle/gÃ¶ster">ğŸ”—</button>
      <button id="focusBtn" class="small" title="Odak modu (tÄ±klayÄ±nca merkezde gÃ¶ster)">ğŸ¯ Odak</button>
      <button id="favoriteBtn" class="small" title="Favorilere ekle">â­</button>
      <select id="history" title="Arama geÃ§miÅŸi" class="small"></select>
    </div>
  </div>

  <div id="spinner"></div>
  <div id="status">HazÄ±r â€” DOI girip Ara'ya basÄ±n.</div>

  <div id="network">
    <button id="centerButton">Ortala</button>
  </div>

  <div id="notes">
    <strong>KÄ±sa kullanÄ±m ve Ã¶nemli notlar</strong><br>
    â€¢ DOI'yi kutuya yapÄ±ÅŸtÄ±rÄ±n (Ã¶r. <code>10.1109/5.771073</code>) ve <b>Ara</b> butonuna tÄ±klayÄ±n.<br>
    â€¢ Uygulama **yalnÄ±zca Semantic Scholar Graph API**'sini kullanÄ±r; tarayÄ±cÄ± CORS kÄ±sÄ±tlarÄ± iÃ§in istekler gÃ¼venilir bir proxy Ã¼zerinden geÃ§er. <br>
    â€¢ TÃ¼m atÄ±f (citations) ve kaynakÃ§a (references) verileri **sayfa sayfa** (pagination) Ã§ekilir â€” bÃ¼yÃ¼k makaleler iÃ§in birkaÃ§ tur sÃ¼rebilir ancak eksiksiz listeleme hedeflenir.<br>
    â€¢ Ortadaki turuncu dÃ¼ÄŸÃ¼m kÃ¶k makaledir. Mavi dÃ¼ÄŸÃ¼mler kaynakÃ§a (references), yeÅŸiller makaleye atÄ±f yapanlardÄ±r (citations).<br>
    â€¢ DÃ¼ÄŸÃ¼mlerin boyutu kesin formÃ¼lle hesaplanÄ±r: <code>size = 5 + Math.sqrt(citationCount) * 4</code> â€” her atÄ±f sayÄ±sÄ± iÃ§in deterministik (aynÄ± veride aynÄ± boyut).<br>
    â€¢ "ğŸ”—" butonuyla baÄŸlantÄ±larÄ± gizleyip sade gÃ¶rÃ¼nÃ¼m alabilirsiniz. "ğŸ¯ Odak" modunu aÃ§Ä±nca tÄ±klanan dÃ¼ÄŸÃ¼mler merkeze alÄ±nÄ±r.<br>
    â€¢ PNG / PDF olarak kaydedebilir, arama geÃ§miÅŸi ve favorileri kullanabilirsiniz.<br>
    â€¢ Geri bildirim & hata raporlarÄ±: <a href="mailto:omurselim@gmail.com">omurselim@gmail.com</a>.<br>
  </div>

  <footer>Â© 2025 <b>Selim Ã–MÃœR</b> â€” <a href="mailto:omurselim@gmail.com">omurselim@gmail.com</a> â€” Ä°zinsiz kullanÄ±lamaz.</footer>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // DOM
  const paperInput = document.getElementById('paperInput');
  const searchButton = document.getElementById('searchButton');
  const sampleButton = document.getElementById('sampleButton');
  const yearFilter = document.getElementById('yearFilter');
  const spinner = document.getElementById('spinner');
  const status = document.getElementById('status');
  const container = document.getElementById('network');
  const centerButton = document.getElementById('centerButton');
  const themeBtn = document.getElementById('themeBtn');
  const savePNG = document.getElementById('savePNG');
  const savePDF = document.getElementById('savePDF');
  const toggleEdgesBtn = document.getElementById('toggleEdges');
  const focusBtn = document.getElementById('focusBtn');
  const favoriteBtn = document.getElementById('favoriteBtn');
  const historySelect = document.getElementById('history');

  // Proxy (Semantic Scholar via proxy to bypass CORS in browser)
  const proxy = 'https://api.allorigins.win/raw?url=';

  // vis options
  const options = {
    nodes: { shape: 'dot', font: { size: 14 }, borderWidth: 2 },
    edges: { width: 2, color: { color: '#999' }, arrows: { to: { enabled: true, scaleFactor: 0.6 } } },
    physics: { stabilization: true, solver: 'barnesHut', barnesHut: { gravitationalConstant: -2000 } },
    interaction: { hover: true, multiselect: false, dragView: true }
  };

  let network = null;
  let graphData = null;
  let lastDOI = null;
  let edgesVisible = true;
  let focusMode = false;

  // history & favorites (localStorage)
  function addToHistory(doi){
    if(!doi) return;
    let h = JSON.parse(localStorage.getItem('sa_history')||'[]');
    h = h.filter(x=>x!==doi);
    h.unshift(doi);
    if(h.length>30) h.pop();
    localStorage.setItem('sa_history', JSON.stringify(h));
    renderHistory();
  }
  function renderHistory(){
    const h = JSON.parse(localStorage.getItem('sa_history')||'[]');
    historySelect.innerHTML = '<option value="">GeÃ§miÅŸ</option>' + h.map(d=>`<option value="${d}">${d}</option>`).join('');
  }
  function toggleFavorite(doi){
    if(!doi) return;
    let f = JSON.parse(localStorage.getItem('sa_fav')||'[]');
    if(f.includes(doi)){ f = f.filter(x=>x!==doi); favoriteBtn.style.opacity=0.6; }
    else { f.unshift(doi); favoriteBtn.style.opacity=1; }
    localStorage.setItem('sa_fav', JSON.stringify(f));
  }
  function updateFavoriteBtn(doi){
    const f = JSON.parse(localStorage.getItem('sa_fav')||'[]');
    favoriteBtn.style.opacity = f.includes(doi)?1:0.6;
  }

  renderHistory();
  historySelect.addEventListener('change', ()=>{ if(historySelect.value) { paperInput.value = historySelect.value; searchPaper(); }});

  // UI events
  sampleButton.onclick = ()=> {
    const samples = ["10.1109/5.771073","10.1038/nrn3241","10.1038/nature12373","10.48550/arXiv.1706.03762"];
    paperInput.value = samples[Math.floor(Math.random()*samples.length)];
    searchPaper();
  };
  themeBtn.onclick = ()=> { document.body.classList.toggle('dark'); themeBtn.textContent = document.body.classList.contains('dark') ? 'â˜€ï¸' : 'ğŸŒ™'; };
  centerButton.onclick = ()=> { if(network) network.fit({ animation: { duration: 600 } }); };
  toggleEdgesBtn.onclick = ()=>{
    edgesVisible = !edgesVisible;
    if(graphData) graphData.edges.getIds().forEach(id=> graphData.edges.update({ id, hidden: !edgesVisible }));
    toggleEdgesBtn.textContent = edgesVisible ? 'ğŸ”—' : 'âœ‚ï¸';
  };
  focusBtn.onclick = ()=> { focusMode = !focusMode; focusBtn.style.opacity = focusMode ? 1 : 0.8; };

  savePNG.onclick = async () => {
    if(!network) return alert('Ã–nce bir grafik oluÅŸturun!');
    const canvas = network.canvas.frame.canvas;
    const dataUrl = canvas.toDataURL('image/png');
    const a = document.createElement('a'); a.href = dataUrl; a.download = 'atif-grafik.png'; a.click();
  };

  savePDF.onclick = async () => {
    if(!network) return alert('Ã–nce bir grafik oluÅŸturun!');
    const canvas = network.canvas.frame.canvas;
    const imgData = canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation:'landscape' });
    const w = pdf.internal.pageSize.getWidth();
    const h = pdf.internal.pageSize.getHeight();
    pdf.addImage(imgData, 'PNG', 10, 10, w-20, h-20);
    pdf.save('atif-grafik.pdf');
  };

  favoriteBtn.onclick = ()=> { toggleFavorite(lastDOI); };

  paperInput.addEventListener('keyup', e => { if(e.key==='Enter') searchPaper(); });
  searchButton.onclick = searchPaper;

  // deterministic size formula: size = 5 + sqrt(citationCount)*4
  function sizeFromCitations(count){
    const c = Math.max(0, Number(count) || 0);
    return Math.round(5 + Math.sqrt(c) * 4);
  }

  // fetch all pages for citations or references (limit 100 per page) â€” returns array
  async function fetchAllPages(apiUrlBase){
    const results = [];
    const limit = 100;
    let offset = 0;
    while(true){
      const pageUrl = `${apiUrlBase}&limit=${limit}&offset=${offset}`;
      const raw = await fetch(proxy + encodeURIComponent(pageUrl));
      if(!raw.ok) throw new Error('Proxy/API hatasÄ±: ' + raw.status);
      const j = await raw.json().catch(()=>null);
      if(!j) break;
      // Semantic Scholar returns data in .data or .citations? For /paper/{id}/citations endpoint it's { data: [...] }
      const pageItems = j.data || j.citations || j.references || j.results || [];
      if(!Array.isArray(pageItems)) break;
      if(pageItems.length === 0) break;
      // adapt shape: when endpoint /paper/{id}/citations returns objects with "citingPaper"
      pageItems.forEach(it => {
        // unify: citation object may be { citingPaper: { paperId, title, ... } } or direct
        const unified = it.citingPaper || it.referencedPaper || it.paper || it;
        results.push(unified);
      });
      if(pageItems.length < limit) break;
      offset += limit;
      // small delay to be nice to API
      await new Promise(r=>setTimeout(r, 200));
      // safety cap to avoid infinite loop
      if(offset > 2000) break;
    }
    return results;
  }

  // main search: Semantic Scholar primary + paging for citations/references
  async function searchPaper(){
    const doi = paperInput.value.trim();
    if(!doi){ status.textContent = 'âš ï¸ LÃ¼tfen DOI girin.'; return; }
    lastDOI = doi; updateFavoriteBtn(doi);
    spinner.style.display = 'block';
    status.textContent = 'ğŸ” Veri Ã§ekiliyor... (Semantic Scholar, sayfalar halinde). Bu biraz sÃ¼rebilir.';
    container.classList.add('loading');

    try {
      // 1) Get main paper to learn paperId and citationCount
      const baseUrl = `https://api.semanticscholar.org/graph/v1/paper/DOI:${encodeURIComponent(doi)}`;
      const fields = '?fields=title,year,authors,doi,paperId,url,citationCount';
      const mainRaw = await fetch(proxy + encodeURIComponent(baseUrl + fields));
      if(!mainRaw.ok) throw new Error('Semantic Scholar ana makale isteÄŸi baÅŸarÄ±sÄ±z');
      const main = await mainRaw.json();
      if(!main || !main.paperId){
        throw new Error('Makale bulunamadÄ± (Semantic Scholar).');
      }

      // 2) Fetch ALL references (pagination) using /paper/{paperId}/references
      const refsUrlBase = `https://api.semanticscholar.org/graph/v1/paper/${encodeURIComponent(main.paperId)}/references?fields=reference.paperId,reference.title,reference.year,reference.doi,reference.authors,reference.citationCount`;
      const references = await fetchAllPages(refsUrlBase);

      // 3) Fetch ALL citations (pagination) using /paper/{paperId}/citations
      const citsUrlBase = `https://api.semanticscholar.org/graph/v1/paper/${encodeURIComponent(main.paperId)}/citations?fields=citingPaper.paperId,citingPaper.title,citingPaper.year,citingPaper.doi,citingPaper.authors,citingPaper.citationCount`;
      const citations = await fetchAllPages(citsUrlBase);

      // unify minimal fields into arrays
      const refsUnified = references.map(r => ({
        title: r.title || r.reference?.title || 'BaÅŸlÄ±k yok',
        paperId: r.paperId || (r.reference && r.reference.paperId) || r.reference?.paperId,
        doi: r.doi || r.reference?.doi || null,
        year: r.year || r.reference?.year || null,
        citationCount: r.citationCount || r.reference?.citationCount || 0,
        url: r.url || (r.reference && r.reference.url) || null
      })).filter(x=>x.title);

      const citsUnified = citations.map(r => {
        const p = r.citingPaper || r;
        return {
          title: p.title || 'BaÅŸlÄ±k yok',
          paperId: p.paperId || null,
          doi: p.doi || null,
          year: p.year || null,
          citationCount: p.citationCount || 0,
          url: p.url || null
        };
      }).filter(x=>x.title);

      // build merged data
      const data = {
        title: main.title,
        year: main.year,
        doi: main.doi,
        paperId: main.paperId,
        citationCount: main.citationCount || 0,
        url: main.url || (main.doi? `https://doi.org/${main.doi}`: null),
        references: refsUnified,
        citations: citsUnified
      };

      // store history
      addToHistory(doi);

      // draw
      fullDraw(data);
      status.textContent = `âœ… "${data.title}" (refs: ${data.references.length}, cits: ${data.citations.length}) gÃ¶sterildi.`;
    } catch (err){
      console.error(err);
      status.textContent = `âŒ Hata: ${err.message || err}.`;
    } finally {
      spinner.style.display = 'none';
      container.classList.remove('loading');
    }
  } // end searchPaper

  // drawing with deterministic sizes and features
  function fullDraw(data){
    const yearLimit = yearFilter.value === 'all' ? 0 : parseInt(yearFilter.value);
    const nodes = [], edges = [];

    const mainId = data.paperId || data.doi || data.title;
    const mainSize = sizeFromCitations(data.citationCount || 0);

    nodes.push({
      id: mainId,
      label: `[ANA]\n${(data.title||'BaÅŸlÄ±k').substring(0,40)}...`,
      title: `${data.title || ''}\n(${data.year || '?'})\nAtÄ±f sayÄ±sÄ±: ${data.citationCount||0}`,
      color: '#f0a30a',
      size: mainSize,
      url: data.url || (data.doi?`https://doi.org/${data.doi}`:null)
    });

    const addList = (list, color, dir) => {
      (list||[]).forEach(item=>{
        if(item.year && yearLimit && item.year < yearLimit) return;
        const id = item.paperId || item.doi || (item.title + Math.random().toString(36).slice(2,8));
        const s = sizeFromCitations(item.citationCount || 0);
        nodes.push({
          id,
          label: (item.title || 'BaÅŸlÄ±k yok').substring(0,40),
          title: `${item.title || ''}\nYÄ±l: ${item.year || '?'}\nAtÄ±f sayÄ±sÄ±: ${item.citationCount || 0}`,
          color,
          size: s,
          url: item.doi ? `https://doi.org/${item.doi}` : (item.url || null)
        });
        edges.push(dir === 'ref' ? { from: mainId, to: id } : { from: id, to: mainId });
      });
    };

    addList(data.references || [], '#4285F4', 'ref');
    addList(data.citations || [], '#34A853', 'cit');

    // Deduplicate nodes by id, keep last
    const uniq = {};
    nodes.forEach(n=>{ uniq[n.id] = n; });
    const finalNodes = Object.values(uniq);

    graphData = { nodes: new vis.DataSet(finalNodes), edges: new vis.DataSet(edges) };
    if(network) network.destroy();
    network = new vis.Network(container, graphData, options);

    // when stabilized -> stop physics to save CPU (auto stop)
    network.on('stabilizationIterationsDone', () => network.physics.stop());

    // click handling: focus mode and open url
    network.on('click', params=>{
      if(params.nodes.length){
        const nodeId = params.nodes[0];
        const node = graphData.nodes.get(nodeId);
        if(focusMode){
          network.focus(nodeId, { scale: 1.2, animation: { duration: 600 } });
        } else {
          // open url if exists, otherwise open Semantic Scholar paper page if paperId present
          if(node && node.url) window.open(node.url, '_blank');
          else if(node && nodeId && nodeId.startsWith('http')) window.open(nodeId, '_blank');
        }
      }
    });

    // center button available
    centerButton.onclick = ()=> { if(network) network.fit({ animation: { duration: 600 } }); };

    // hide/show edges initial state
    graphData.edges.getIds().forEach(id => graphData.edges.update({ id, hidden: !edgesVisible }));

    // light flourish
    container.animate([{ boxShadow: '0 0 0px var(--shadow)' }, { boxShadow: '0 0 25px var(--shadow)' }], { duration: 700, iterations: 2 });
  }

  // expose searchPaper in window for debugging (optional)
  window.searchPaper = searchPaper;
});
</script>
</body>
</html>
